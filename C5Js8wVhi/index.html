<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, user-scalable=no"
/>
<meta name="keywords" content="micromatrix 静态博客 " />
<meta name="description" content="一个菜鸟的笔记网站" />
<meta name="theme-color" content="#000" />
<title>记录一次vue2函数式组件开发+单粒模式 | micromatrix</title>
<link
  rel="shortcut icon"
  href="/favicon.ico?v=1668997999962"
/>
<link
  rel="stylesheet"
  href="/media/css/pisces.css"
/>
<link rel="stylesheet" href="/media/fonts/font-awesome.css" />
<link
  href="//fonts.loli.net/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet"
  type="text/css"
/>

<link
  href="/media/hljs/styles/atom-one-light.css"
  rel="stylesheet"
/>

<link rel="stylesheet" href="/styles/main.css" />
<script
  async
  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"
></script>

<script src="/media/js/jquery.js"></script>
<script src="/media/hljs/highlight.js"></script>
<!-- <script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous"> -->
<script src="https://unpkg.com/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://unpkg.com/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link
  rel="stylesheet"
  href="https://unpkg.com/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq"
  crossorigin="anonymous"
/>

<script>
  window.MathJax = {
    tex: {
      inlineMath: [
        ['$', '$'],
        ['\\(', '\\)'],
      ],
      displayMath: [
        ['$$', '$$'],
        ['\\[', '\\]'],
      ],
    },
    options: {
      skipHtmlTags: [
        'script',
        'noscript',
        'style',
        'textarea',
        'pre',
        'code',
        'a',
        'annotation',
        'annotation-xml',
      ],
      ignoreHtmlClass: 'tex2jax_ignore|crayon-.*', // 'crayon-' 开头的类，属于Wordpress代码高亮库，这部分不需要处理，否则会导致显示不正确,这部分是正则式，多条之间用'|'分割
      processHtmlClass: 'tex2jax_process',
    },
    //禁用右键菜单
    renderActions: {
      addMenu: [0, '', ''],
    },
  }
</script>
<script
  type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
></script>
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=G-6C69RY5CT2"
></script>
<script>
  window.dataLayer = window.dataLayer || []
  function gtag() {
    dataLayer.push(arguments)
  }
  gtag('js', new Date())

  gtag('config', 'G-6C69RY5CT2')
</script>
 
<script>
  var _hmt = _hmt || []
  ;(function () {
    var hm = document.createElement('script')
    hm.src = 'https://hm.baidu.com/hm.js?2d73de1a8599f1c3ead11d566428e265'
    var s = document.getElementsByTagName('script')[0]
    s.parentNode.insertBefore(hm, s)
  })()
</script>
<script
  async
  src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5901616898778649"
  crossorigin="anonymous"
></script>
 

  <meta name="description" content="记录一次vue2函数式组件开发+单粒模式" />
  <meta name="keywords" content="Javascript,Vue" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="pisces">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>micromatrix</span>
            </a>  
          
        </div>
        
          <p class="subtitle">曲则全，枉则直。洼则盈，敝则新。少则得，多则惑。是以圣人抱一为天下式。不自见，故明。不自是，故彰。不自伐，故有功。不自矜，故长。夫唯不争，故天下莫能与之争。古之所谓&#34;曲则全&#34;者，岂虚言哉？诚全而归之。</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                
                  <a href="/" target="_self">
                    首页
                  </a>
                
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                
                  <a href="/archives" target="_self">
                    归档
                  </a>
                
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                
                  <a href="/tags" target="_self">
                    标签
                  </a>
                
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                
                  <a href="/about" target="_self">
                    关于
                  </a>
                
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout pisces ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body pisces" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">DavidMorgan</p>
    
    <div class="site-description right-motion">
      
        <p id="binft">不忘初心，方得始终。\n 初心易得，始终难守。</p>
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">43</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">19</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://micromatrix.cf/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E7%BB%84%E4%BB%B6%E7%BC%96%E5%86%99%E8%BF%87%E7%A8%8B">组件编写过程</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    jQuery.Velocity(hideElement, 'stop');
    jQuery.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        jQuery.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://micromatrix.cf/C5Js8wVhi/"> 记录一次vue2函数式组件开发+单粒模式 </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2022-05-11 15:37:34">2022-05-11</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">标签:</span>
       
      <a href="https://micromatrix.cf/tag/FUY6vZS-4p/"> <span>Javascript</span> </a>、   
      <a href="https://micromatrix.cf/tag/JQWdJ2D9bI/">
        <span>Vue</span>
      </a>
       
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span
        >4<span class="language" data-lan="minute"
          >分钟</span
        ></span
      >
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span
        >830<span class="pc-show language" data-lan="words"
          >字数</span
        ></span
      >
    </span>
      
    <span
      id="/C5Js8wVhi/"
      data-flag-title="记录一次vue2函数式组件开发+单粒模式"
      class="meta-item pc-show leancloud_visitors"
    >
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span
        ><span class="language" data-lan="view">浏览量:</span>:<span
          class="leancloud-visitors-count"
        ></span
      ></span>
    </span>
    
  </div>
</section>

            <div class="post-body next-md-body" id="post_body">
              <h2 id="前言">前言</h2>
<p>最近遇到个需求，需要一个类似于钉钉头部的菜单栏，因为钉钉的头部可以通过函数来渲染需要组件的样式，以及回调函数。所以，第一眼想到了，用单粒模式来模仿这个。那么我们就需要一个全局组件</p>
<!-- more -->
<h2 id="组件编写过程">组件编写过程</h2>
<p>首先我们编写一个基础的vue组件，来作为基础的布局。</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;header-container-wrapper&quot;&gt;
    &lt;plugin :render=&quot;renderLeftFunc&quot; v-show=&quot;this.renderLeft&quot;&gt;&lt;/plugin&gt;

    &lt;div class=&quot;path-nav-name&quot;&gt;
      {{ navPath }}
    &lt;/div&gt;
    &lt;plugin :render=&quot;renderRightFunc&quot; v-show=&quot;this.renderRight&quot;&gt;&lt;/plugin&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import plugin from &quot;./render.js&quot;;
export default {
  components: {
    plugin
  },
  computed: {
    renderLeftFunc() {
      return this.renderLeft || function() {};
    },
    renderRightFunc() {
      return this.renderRight || function() {};
    }
  },
  data() {
    //header.js中data的数据定义一样，这里只是方便观察修改组件
    return {
      navPath: &quot;&quot;,
      showLeftContent: false,
      showRightContent: false,
      renderLeft: null,
      renderRight: null,
      pluginName: &quot;&quot;
    };
  }
};
&lt;/script&gt;

&lt;style scoped lang=&quot;scss&quot;&gt;
.header-container-wrapper {
  display: flex;
  align-items: center;
  justify-content: space-around;
  height: 60px;
  .left-container,
  .right-container {
    padding: 16px 24px;
    height: 100%;
  }
  .path-nav-name {
    font-weight: 700;
    font-size: 22px;
    color: #333333;
    margin-left: auto;
    flex: 1 1 auto;
    text-align: center;
  }
}
&lt;/style&gt;
</code></pre>
<p>为了能在函数中使用render语法渲染组件，这里封装一个render.js来渲染组件</p>
<pre><code class="language-javascript">export default {
  //vue2的render示例
  functional: true,
  name: &quot;plugin&quot;,
  props: {
    render: Function,
  },
  render: (h, ctx) =&gt; {
    return ctx.props.render(h)
  }
}
</code></pre>
<p>这个时候我们通过vue.extend这个操作语句来生产一个组件对象。并且我们可以在这个对象上操作前面的基础组件。</p>
<pre><code class="language-javascript">import Vue from 'vue';
import Header from &quot;./index.vue&quot;;


const Component = Vue.extend(Header);
let instance = null;
function HeaderBox (tarEl, options) {
  if (!instance) {

    instance = new Component({
      el: document.createElement('div'),
      data () {
        return options;
      }
    });
    //将头部元素插入到第一位
    //返回生成的元素，然后把它挂载到需要挂载到dom元素上
    tarEl.insertBefore(instance.$el, tarEl.firstChild)
  } else {
    // 存在实例，则合并options，更新视图
    Object.assign(instance, options);
  }
}
//添加返回按钮
HeaderBox.addLeftBtn = (renderObj, callback) =&gt; {
  if (instance) {
    instance.showLeftContent = true;
    instance.renderLeft = () =&gt; {
      let h = instance.$createElement;
      return h(
        &quot;div&quot;,
        {
          class: &quot;left-container&quot;,
          on: {
            click: callback
          }
        },
        [
          h(&quot;Icon&quot;, {
            props: {
              type: &quot;ios-arrow-back&quot;
            },
            style: &quot;font-size:24px;&quot;
          }),
          h(
            &quot;span&quot;,
            {
              style: &quot;font-size:18px;&quot;
            },
            &quot;返回&quot;
          )
        ]
      );
    };
  }
}
//移除返回按钮
HeaderBox.removeLeftBtn = () =&gt; {
  if (instance) {
    instance.renderLeft = null;
  }
}

HeaderBox.addTopTitle = (title) =&gt; {
  if (instance) {
    instance.navPath = title;
  }
}
HeaderBox.removeTopTitle = () =&gt; {
  if (instance) {
    instance.navPath = &quot;&quot;
  }
}

export default HeaderBox;
</code></pre>
<p>上面的代码示例中，我们通过instance对象可以操控到基础组件里面的data定义的参数。通过操作data里面的参数，传递render语法来控制渲染组件。其中h由于没有自动注入，所以直接使用时undefined，为了让他能正常工作，参考官网给的代码: const h = this.createElement;我们通过instance对象上的$createElement来赋值h。</p>
<p>最后我们通过在main.js中全局注册</p>
<pre><code class="language-javascript">import HeaderBox from &quot;@/components/header/header.js&quot;;
Vue.prototype.$HeaderBox = HeaderBox;
</code></pre>
<p>这样的话任何页面都能通过this.$HeaderBox.addTopTitle(&quot;测试表头&quot;);这样来生成自己的样式，也可以通过扩展header.js里面的HeaderBox对象的属性来扩充基础的组件。</p>
<p>使用案例如下代码</p>
<pre><code class="language-javascript">//vue2 中的操作
mounted(){
// 第一次使用初始化，就是你要挂载到哪里到节点下
    this.$HeaderBox(this.$refs.rightHeader);
    this.$nextTick(() =&gt; {
      this.$HeaderBox.addLeftBtn({}, () =&gt; {
        this.$router.go(-1);
      });
    });
}
</code></pre>

            </div>
            
              <div class="reward-btn">
                <div class="reward-btn-text">赞赏</div>
              </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      DavidMorgan
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://micromatrix.cf/C5Js8wVhi/" title="记录一次vue2函数式组件开发+单粒模式">https://micromatrix.cf/C5Js8wVhi/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://micromatrix.cf/tag/FUY6vZS-4p/"># Javascript</a>
    
      <a href="https://micromatrix.cf/tag/JQWdJ2D9bI/"># Vue</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="vue3源码学习-1-生成配置信息" href="https://micromatrix.cf/7LRUK2OlY/">vue3源码学习-1-生成配置信息</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="vue3源码学习-1-生成配置信息" href="https://micromatrix.cf/7LRUK2OlY/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="CSS3 动态设定div的宽高比" href="https://micromatrix.cf/HQp-4ueUO/">CSS3 动态设定div的宽高比</a>
        <a class="nav-mobile-next" title="CSS3 动态设定div的宽高比" href="https://micromatrix.cf/HQp-4ueUO/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  <!-- <script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script> -->
<script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>

<style>
  .v .veditor {
    min-height: 10rem;
    background-image: url('https://github.com/Stonewalling/matrix_file_server/blob/main/img/book_cover.png');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
    background-color: rgba(255, 255, 255, 0);
    resize: none;
  }

  .v .vwrap {
    border: 1px solid #000 !important;
  }

  .v .vbtn {
    padding: .4rem 1.2rem !important;
    border-color: #fff !important;
    background-color: #49b1f5 !important;
    color: #fff !important;
    font-size: .7rem !important;
  }

  .v .vcards .vcard .vh .vmeta .vat {
    padding: 0 .8rem !important;
    border: 1px solid #00c4b6 !important;
    border-radius: 5px !important;
    color: #00c4b6 !important;
  }
</style>
<script>
  new Valine({
    el: '#vcomments',
    appId: 'lMHSEWBjTMGqImThGQ8xzwIm-MdYXbMMI',
    appKey: 'zXc3TDxAkSzHLmAyjxQgQurz',
    avatar: 'monsterid',
    placeholder: '来参加讨论吧',
    pageSize: '20',
    lang: 'zh-cn',
    enableQQ: 'true' === 'true',
    visitor: 'true' === 'true',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'true',
    serverURLs: 'https://lmhsewbj.api.lncldglobal.com',
		recordIP: 'true' === 'true',
  });
</script>

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <center id="runTimeBox">
      已运行:<span id="run_time"></span>
    </center>
    <span id="busuanzi_container_site_pv">浏览数:<span id="busuanzi_value_site_pv"></span> 次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">访客数:<span id="busuanzi_value_site_uv"></span> 人</span>

    <script>
      BirthDay = new Date('2022-05-10');
      if (BirthDay.getTime()) {
        function runTime() {
          str = "";
          today = new Date();
          timeold = today.getTime() - BirthDay.getTime();
          msPerDay = 24 * 60 * 60 * 1000;
          e_daysold = timeold / msPerDay;
          daysold = Math.floor(e_daysold);
          str += daysold + "天";
          return str;
        }
        setInterval(function () {
          $("#run_time").html(runTime());
        }, 1000);
      } else {
        document.querySelector('.footer').removeChild(document.querySelector('#runTimeBox'));
      }
    </script>
    <div class="poweredby">
      Powered by <a href="https://github.com/Stonewalling/" target="_blank">MicroMatrix</a>
    </div>
  </footer>
  
    
        <div class="pisces back-to-top" id="back_to_top">
          <i class="fa fa-arrow-up"></i>
          
            <span class="scrollpercent"> <span id="back_to_top_text">0</span>% </span>
            
        </div>
        
                  
                        
</div>
<script>
  let sideBarOpen = "sidebar-open";
  let body = document.body;
  let back2Top = document.querySelector("#back_to_top"),
    back2TopText = document.querySelector("#back_to_top_text"),
    drawerBox = document.querySelector("#drawer_box"),
    rightSideBar = document.querySelector(".sidebar"),
    viewport = document.querySelector("body");

  function scrollAnimation(currentY, targetY) {
    let needScrollTop = targetY - currentY;
    let _currentY = currentY;
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10);
      _currentY += dist;
      window.scrollTo(_currentY, currentY);
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY);
      } else {
        window.scrollTo(_currentY, targetY);
      }
    }, 1);
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener("scroll", function (e) {
    let percent =
      (document.scrollingElement.scrollTop /
        (document.scrollingElement.scrollHeight -
          document.scrollingElement.clientHeight)) *
      100;
    if (percent > 1 && !back2Top.classList.contains("back-top-active")) {
      back2Top.classList.add("back-top-active");
    }
    if (percent == 0) {
      back2Top.classList.remove("back-top-active");
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  let hasCacu = false;
  window.addEventListener("resize", function (e) {
    calcuHeight();
  });

  function calcuHeight() {
    // 动态调整站点概览高度
    if (
      (!hasCacu && back2Top.classList.contains("pisces")) ||
      back2Top.classList.contains("gemini")
    ) {
      let sideBar = document.querySelector(".sidebar");
      let navUl = document.querySelector("#site_nav");
      sideBar.style =
        "margin-top:" + (navUl.offsetHeight + navUl.offsetTop + 15) + "px;";
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false,
    MOTION_TIME = 300,
    RIGHT_MOVE_DIS = "320px";

  if (drawerBox) {
    let rightMotions = document.querySelectorAll(".right-motion");
    let right = drawerBox.classList.contains("right");

    let transitionDir = right
      ? "transition.slideRightIn"
      : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingRight: "0px",
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS,
      };
      closeProp = {
        paddingLeft: "0px",
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      jQuery.Velocity(rightSideBar, "stop");
      jQuery.Velocity(viewport, "stop");
      jQuery.Velocity(rightMotions, "stop");
      if (open) {
        jQuery.Velocity(
          rightSideBar,
          {
            width: RIGHT_MOVE_DIS,
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, transitionDir, {});
            },
          }
        );
        jQuery.Velocity(viewport, openProp, {
          duration: MOTION_TIME,
        });
      } else {
        jQuery.Velocity(
          rightSideBar,
          {
            width: "0px",
          },
          {
            duration: MOTION_TIME,
            begin: function () {
              jQuery.Velocity(rightMotions, {
                opacity: 0,
              });
            },
          }
        );
        jQuery.Velocity(viewport, closeProp, {
          duration: MOTION_TIME,
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle("muse-line");
      }
      drawerBox.classList.toggle(sideBarOpen);
    };
  }

  // 链接跳转
  let newWindow = "true";
  if (newWindow === "true") {
    let links = document.querySelectorAll(".post-body a");
    links.forEach((item) => {
      if (!item.classList.contains("btn")) {
        item.setAttribute("target", "_blank");
      }
    });
  }

  let faSearch = document.querySelector("#fa_search");
  faSearch &&
    faSearch.addEventListener("click", function () {
      document.querySelector("#search_mask").style = "";
    });

  // 代码高亮
  hljs.initHighlightingOnLoad();

  // 离开当前页title变化
  var leaveTitle = "你怎么忍心离开>_<";
  var normal_title = document.title;
  if (leaveTitle) {
    document.addEventListener("visibilitychange", function () {
      if (document.visibilityState == "hidden") {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }
</script>

<link rel="stylesheet" href="/media/css/jquery.fancybox.css" />
<script src="/media/js/jquery.fancybox.js"></script>

<script>
  let images = document.querySelectorAll(".section img");
  images.forEach((image) => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement("a");
    aelem.href = image.src;
    aelem.dataset["fancybox"] = "images";
    aelem.dataset["rel"] = "fancybox-button";
    aelem.classList.add("fancybox");
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  });
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
            <img id="wx" class="reward-img" src="/media/images/custom-wxImg.jpg" alt="赞赏码">
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip"> </p>
    </div>
    <div class="bottom">
      
      
      <div id="wxBtn" class="pay-text">
        微信支付
      </div>
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        jQuery.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        jQuery.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        jQuery.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        jQuery.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      jQuery.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      jQuery.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/syf8X1spe/"" data-c="
          &lt;h2 id=&#34;工具说明&#34;&gt;工具说明&lt;/h2&gt;
&lt;p&gt;本文采用的工具是qv2ray,使用的代理节点类型是v2ray。文章涉及的工具qv2ray分为2部分，一个是外壳工具&lt;code&gt;qv2ray&lt;/code&gt;，另一个是内核&lt;code&gt;xray&lt;/code&gt;。这里提到的是电脑端使用的工具。&lt;br&gt;
对于移动端，IOS需要下载&lt;code&gt;小火箭(Shadowrocket)&lt;/code&gt;，Android需要下载&lt;code&gt;V2RayNG&lt;/code&gt;。移动端是不需要安装&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;qv2ray是一个图形界面外壳，&lt;strong&gt;真正能运行节点配置文件的是内核xray&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Xray是V2ray的超集。虽然最新版V2ray删除了XTLS，但仍保留VLESS协议。Xray提供完整的VLESS和XTLS支持，目前是V2ray的超集，但后续Xray可能会有会有自己的发展方向。&lt;/li&gt;
&lt;li&gt;Shadowrocket是一个通用的 iOS VPN 应用，它支持众多协议，如 Shadowsocks、VMess、SSR 等。这个目前只有美区苹果账号才可以下载，需要$2.99。&lt;/li&gt;
&lt;li&gt;V2RayNG 是一个基于 V2Ray 内核的 Android 应用，它可以创建基于 VMess 的 VPN 连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;工具下载&#34;&gt;工具下载&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;此处提供的是windows版本所需要的工具:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;qv2ray:&lt;br&gt;
&lt;a href=&#34;https://matrixfrp.gq/https://github.com/Qv2ray/Qv2ray/releases/download/v2.7.0/Qv2ray-v2.7.0-Windows.7z&#34;&gt;qv2ray_windows版本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;xray内核:&lt;br&gt;
如果你的是x86架构的的windows,下载这个&lt;br&gt;
&lt;a href=&#34;https://matrixfrp.gq/https://github.com/XTLS/Xray-core/releases/download/v1.6.1/Xray-windows-64.zip&#34;&gt;xray_windows_x86_64版本&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此处提供的是mac版本所需要的工具&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;qv2ray:&lt;br&gt;
&lt;a href=&#34;https://matrixfrp.gq/https://github.com/Qv2ray/Qv2ray/releases/download/v2.7.0/Qv2ray-v2.7.0-macOS-x64.dmg&#34;&gt;qv2ray_mac版本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;xray内核:&lt;br&gt;
如果你的是inter版本的mac,下载这个&lt;br&gt;
&lt;a href=&#34;https://matrixfrp.gq/https://github.com/XTLS/Xray-core/releases/download/v1.6.1/Xray-macos-64.zip&#34;&gt;xray_mac_64版本&lt;/a&gt;&lt;br&gt;
如果你的是最新的m芯片的mac，下载这个&lt;br&gt;
&lt;a href=&#34;https://matrixfrp.gq/https://github.com/XTLS/Xray-core/releases/download/v1.6.1/Xray-macos-arm64-v8a.zip&#34;&gt;xray_mac_arm64版本&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此处提供Android工具&lt;br&gt;
&lt;a href=&#34;https://matrixfrp.gq/https://github.com/2dust/v2rayNG/releases/download/1.7.23/v2rayNG_1.7.23.apk&#34;&gt;V2RayNG&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;各个平台安装配置教程&#34;&gt;各个平台安装配置教程&lt;/h2&gt;
&lt;p&gt;下载你系统对应的工具，下面的教程需要使用到。&lt;/p&gt;
&lt;h3 id=&#34;windows-平台工具配置教程&#34;&gt;windows 平台工具配置教程&lt;/h3&gt;
&lt;p&gt;下载windows所需要的工具，之后解压。得到如下2个文件夹&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668130840326.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;deployment&lt;/code&gt;是从qv2ray下载链接文件解压出来的，&lt;code&gt;Xray-windows-64&lt;/code&gt;是xray下载文件链接解压出来的。&lt;br&gt;
将他们放在你需要放置的文件夹下。例如我就放在桌面下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开deployment文件夹，点击其目录下的qv2ray.exe程序，如下图&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668131118676.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;点击上方的首选项-&amp;gt;内核设置，在&lt;code&gt;V2Ray核心可执行文件路径&lt;/code&gt;处点击选择,在弹出的文件框中找到&lt;code&gt;Xray-windows-64&lt;/code&gt;文件夹，点击进去，找到xray,点击打开。&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668131966162.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;同样在该界面的&lt;code&gt;V2ray资源目录&lt;/code&gt;处点击选择，找到&lt;code&gt;Xray-windows-64&lt;/code&gt;点击选择文件夹就行。&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668132166217.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;点击检查V2ray核心设置,提示核心检查到了，就是成功完成了设置，关闭弹框，点击下面的OK保存设置。&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668132257305.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668132391104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
上面的是windows工具设置教程，这个时候还不能科学上网，需要导入节点才可以上网。&lt;a href=&#34;#%E7%94%B5%E8%84%91%E7%AB%AF%E5%B9%B3%E5%8F%B0%E5%AF%BC%E5%85%A5%E6%95%99%E7%A8%8B&#34;&gt;导入节点教程&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mac平台工具配置教程&#34;&gt;mac平台工具配置教程&lt;/h3&gt;
&lt;p&gt;下载Mac所需要的工具，得到如下2个文件&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668135254005.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;Qv2ray-v2.7.0-macOS-x64.dmg&lt;/code&gt;是从qv2ray的执行程序，&lt;code&gt;Xray-macos-64.zip&lt;/code&gt;是xray内核，解压它，放在你希望你存放的位置。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;点击&lt;code&gt;Qv2ray-v2.7.0-macOS-x64.dmg&lt;/code&gt;，将它拖入到Applications，如下图&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668135413846.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;点击上方的首选项-&amp;gt;内核设置，在&lt;code&gt;V2Ray核心可执行文件路径&lt;/code&gt;处点击选择,在弹出的文件框中找到&lt;code&gt;Xray-macos-64.zip&lt;/code&gt;解压的文件夹，点击进去，找到xray,点击打开。&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668135854448.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;同样在该界面的&lt;code&gt;V2ray资源目录&lt;/code&gt;处点击选择，找到&lt;code&gt;Xray-macos-64.zip&lt;/code&gt;解压的文件夹，点击选择文件夹就行。&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668135922963.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;点击检查V2ray核心设置,提示核心检查到了，就是成功完成了设置，关闭弹框，点击下面的OK保存设置。&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668135980869.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668135986479.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
上面的是Mac工具设置教程，这个时候还不能科学上网，需要导入节点才可以上网。&lt;a href=&#34;#%E7%94%B5%E8%84%91%E7%AB%AF%E5%B9%B3%E5%8F%B0%E5%AF%BC%E5%85%A5%E6%95%99%E7%A8%8B&#34;&gt;导入节点教程&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;iphone平台工具配置教程&#34;&gt;Iphone平台工具配置教程&lt;/h3&gt;
&lt;p&gt;需要一个美国账号，购买了价值2.99美元的&lt;code&gt;小火箭(Shadowrocket)&lt;/code&gt;,这里假设你已经有一个该类型的账号&lt;br&gt;
在商店里切换你的美国账号，点击右上角的头像&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668137374009.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668137387922.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
滑到下面退出登录&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668137396144.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后输入你的账号登录&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668137405073.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在软件搜索框中搜索Shadowrocket点击安装&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668137419066.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
同样这里也只是工具的安装，这个时候还不能科学上网，需要导入节点才可以上网。&lt;a href=&#34;#ios%E5%B0%8F%E7%81%AB%E7%AE%ADshadowrocket&#34;&gt;导入节点教程&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;android平台工具配置教程&#34;&gt;Android平台工具配置教程&lt;/h3&gt;
&lt;p&gt;下载上面提供的链接，然后安装。就完成了。同样这里也只是工具的安装，这个时候还不能科学上网，需要导入节点才可以上网。&lt;a href=&#34;#android-v2rayng%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B&#34;&gt;导入节点教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;各个平台导入节点教程&#34;&gt;各个平台导入节点教程&lt;/h2&gt;
&lt;p&gt;电脑端平台导入教程和移动端不一样，电脑端基本一样，移动端扫码就行。&lt;/p&gt;
&lt;h3 id=&#34;电脑端平台导入教程&#34;&gt;电脑端平台导入教程&lt;/h3&gt;
&lt;p&gt;打开&lt;code&gt;Qv2ray&lt;/code&gt;程序，点击导入-&amp;gt;高级-&amp;gt;打开JSON编辑器，删除左侧框中的默认花括号，粘贴代理给你的JSON配置文件，点击OK就可以添加完成你的节点&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668133628383.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668133479759.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668133716447.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后点击&lt;code&gt;Qv2ray&lt;/code&gt;右上角的三角按钮，开启代理上网，不需要用的时候再点击一次就可以关闭代理&lt;/p&gt;
&lt;h3 id=&#34;ios小火箭shadowrocket&#34;&gt;IOS小火箭(Shadowrocket)&lt;/h3&gt;
&lt;p&gt;点击安装好的&lt;code&gt;Shadowrocket&lt;/code&gt;，点击左上角是扫码添加节点，点击右上角是手动添加节点。这里采用扫码添加节点&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668137954904.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
添加之后节点信息就出来了，然后节点信息旁边的感叹号是编辑节点按钮&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668137961699.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如果节点不可以用，尝试编辑节点信息，将允许不安全打开&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668137967050.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
节点信息无误的话，点击&lt;strong&gt;未连接&lt;/strong&gt;旁的开关就可以使用代理上网了&lt;/p&gt;
&lt;h3 id=&#34;android-v2rayng使用教程&#34;&gt;Android V2rayNG使用教程&lt;/h3&gt;
&lt;p&gt;点击安装好的V2rayNG程序&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668145619090.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击右上角 &lt;code&gt;+&lt;/code&gt; 按钮&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668145945500.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
点击扫描二维码&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668145951546.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
扫描我们给与的二维码后下方出现新得节点，点击新节点后，再点击右下角得连接按钮&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668145975927.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
连接成功后再次点击下方的格子，会提示连接成功，并且说明延迟&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1668145992488.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">代理工具使用说明</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/I1MPweBFN/"" data-c="
          &lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;
&lt;p&gt;本文记录一下Vue3的一个基本的开发框架的搭建。主要在公司开发业务，主体框架不用每次都搭建。时间长了就容易忘记了，当初的框架如何搭建的。文章记录的框架搭建的主要实现功能如题，然后研究一些快捷的操作。例如，ts定义的空间自动导入等等。&lt;/p&gt;
&lt;h2 id=&#34;工具介绍&#34;&gt;工具介绍&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Vite 是一种新型前端构建工具，能够显著提升前端开发体验。细致的介绍看&lt;a href=&#34;https://cn.vitejs.dev/guide/&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vue3 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。&lt;/li&gt;
&lt;li&gt;TypeScript  是一门静态类型、弱类型的语言。 TypeScript 是完全兼容JavaScript 的，它不会修改JavaScript 运行时的特性。 TypeScript 可以编译为JavaScript，然后运行在浏览器、Node.js 等任何能运行JavaScript 的环境中。&lt;/li&gt;
&lt;li&gt;Axios 是一个基于promise 网络请求库，作用于 node.js 和浏览器中。&lt;/li&gt;
&lt;li&gt;Pinia 是 Vue 的存储库，它允许您跨组件/页面共享状态。详细的介绍看&lt;a href=&#34;https://pinia.web3doc.top/introduction.html&#34;&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vue Router 是 Vue.js 的官方路由。它与 Vue.js 核心深度集成，让用 Vue.js 构建单页应用变得轻而易举。
&lt;blockquote&gt;
&lt;p&gt;Vue Router 和 Vue 的版本有一个范围支持的。前面使用了Vue3.x所以Vue Router使用4.x&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;使用vite&#34;&gt;使用Vite&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Vite 需要 Node.js 版本 14.18+，16+。所以安装之前检查你的node版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# npm 6.x
npm create vite@latest my-vue-app --template vue

# npm 7+, extra double-dash is needed:
npm create vite@latest my-vue-app -- --template vue

# yarn
yarn create vite my-vue-app --template vue

# pnpm
pnpm create vite my-vue-app --template vue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;--template 后面的参数有 &lt;code&gt;vanilla&lt;/code&gt;，&lt;code&gt;vanilla-ts&lt;/code&gt;，&lt;code&gt;vue&lt;/code&gt;，&lt;code&gt;vue-ts&lt;/code&gt;，&lt;code&gt;react&lt;/code&gt;，&lt;code&gt;react-ts&lt;/code&gt;，&lt;code&gt;preact&lt;/code&gt;，&lt;code&gt;preact-ts&lt;/code&gt;，&lt;code&gt;lit&lt;/code&gt;，&lt;code&gt;lit-ts&lt;/code&gt;，&lt;code&gt;svelte&lt;/code&gt;，&lt;code&gt;svelte-ts&lt;/code&gt;。查看&lt;a href=&#34;https://github.com/vitejs/vite/tree/main/packages/create-vite&#34;&gt;create-vite&lt;/a&gt;以获取每个模板的更多细节。&lt;br&gt;
这里就使用命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm create vite@latest my-vue-app -- --template vue
# 执行之后安装它给出的提示安装模块和启动
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到此Vue3 + Vite + Ts就很简单的完成了，但是这还只是一部分内容&lt;/p&gt;
&lt;h2 id=&#34;安装axios&#34;&gt;安装Axios&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm install axios
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完成之后，创建一个如下的文件&lt;code&gt;src/assets/js/my-axios.ts&lt;/code&gt;,这里要做一个自己的项目接口配置，可以参考我的，根据个人需求来改动。本文件完成了以下几个需求。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在具体页面中通过&lt;code&gt;api.get&lt;/code&gt;或者&lt;code&gt;api.post&lt;/code&gt;这种方式来调用函数，创建对应的方法。&lt;/li&gt;
&lt;li&gt;通过请求前拦截和请求后拦截来做一个身份的验证和一个数据加载动画。&lt;/li&gt;
&lt;li&gt;有时候需要手动上传图片数据，可以对接口请求参数类型是否是&lt;code&gt;[object FormData]&lt;/code&gt;头部修改字段。&lt;br&gt;
还需要安装&lt;code&gt; @types/node&lt;/code&gt;包，因为文件中使用到了Timeout函数，来处理加载动画到操作。&lt;br&gt;
以及安装element-plus，使用其中的信息组件&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;@types是什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有些包并不是 TypeScript 编写的，自然也不会导出 TypeScript 声明文件。所以在TS项目中使用会报错，TS官方给了2个解决方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装 @types&lt;/li&gt;
&lt;li&gt;自己 declare module&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 安装@types/node
npm install @types/node
# 安装element-plus
npm install element-plus --save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自定义的axios文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;var root = &#39;/api&#39;

import axios, { AxiosRequestConfig, AxiosRequestHeaders } from &#39;axios&#39;
import { ElMessage as Message } from &#39;element-plus&#39;

// 自定义判断元素类型JS
function toType(obj: any): string {
  return {}.toString
    .call(obj)
    .match(/\s([a-zA-Z]+)/)![1]
    .toLowerCase()
}
// 参数过滤函数
function filterNull(o: any) {
  for (var key in o) {
    if (o[key] === null) {
      delete o[key]
    }
    if (toType(o[key]) === &#39;string&#39;) {
      o[key] = o[key].trim()
    } else if (toType(o[key]) === &#39;object&#39;) {
      o[key] = filterNull(o[key])
    } else if (toType(o[key]) === &#39;array&#39;) {
      o[key] = filterNull(o[key])
    }
  }
  return o
}
/*
  接口处理函数
  这个函数每个项目都是不一样的，我现在调整的是适用于
  https://cnodejs.org/api/v1 的接口，如果是其他接口
  需要根据接口的参数进行调整。参考说明文档地址：
  https://cnodejs.org/topic/5378720ed6e2d16149fa16bd
  主要是，不同的接口的成功标识和失败提示是不一致的。
  另外，不同的项目的处理方法也是不一致的，这里出错就是简单的alert
*/

function apiAxios(
  method: string,
  url: string,
  params: null | string | object,
  success: any,
  failure: any
) {
  let contentTypeIsJson = false
  if (params &amp;amp;&amp;amp; typeof params != &#39;string&#39;) {
    params = filterNull(params)
  } else contentTypeIsJson = true

  // axios 对特殊字符处理
  if (params &amp;amp;&amp;amp; (method === &#39;GET&#39; || method === &#39;DELETE&#39;)) {
    const arr: Array&amp;lt;string&amp;gt; = []
    Object.entries(params).forEach((item) =&amp;gt; {
      arr.push(`${item[0]}=${encodeURIComponent(item[1])}`)
    })
    url = `${url}?${arr.join(&#39;&amp;amp;&#39;)}`
  }
  axios({
    method: method,
    url: url,
    data: method === &#39;POST&#39; || method === &#39;PUT&#39; ? params : null,
    // params: method === &#39;GET&#39; || method === &#39;DELETE&#39; ? params : null,
    params: method === &#39;GET&#39; || method === &#39;DELETE&#39; ? &#39;&#39; : null,
    baseURL: root,
    withCredentials: true,
    crossDomain: true,
    transformRequest: [
      function (data) {
        // Do whatever you want to transform the data
        if (contentTypeIsJson) return data
        let ret = &#39;&#39;
        for (let it in data) {
          ret +=
            encodeURIComponent(it) + &#39;=&#39; + encodeURIComponent(data[it]) + &#39;&amp;amp;&#39;
        }
        return ret
      },
    ],
    headers: {
      // &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,
      &#39;Content-Type&#39;: contentTypeIsJson
        ? &#39;application/json&#39;
        : &#39;application/x-www-form-urlencoded&#39;,
    },
  } as AxiosRequestConfig&amp;lt;any&amp;gt;)
    .then(function (res) {
      let response = res.data
      if (response.code == 302) {
        window.location.href = response.urlToRedirectTo
        return
      } else if (response.code == 0) {
        if (success) {
          success(response)
        }
      } else {
        if (failure) {
          failure(response)
        } else {
          if (response.data == 2) {
            Message.error(response.msg) //错误处理
            setTimeout(() =&amp;gt; {
              location.reload()
            }, 1000)
          } else {
            Message.info(response.msg) //错误处理
          }
        }
      }
    })
    .catch(function (err) {
      let res = err.response
      console.error(res || err)
      if (res) {
        Message.closeAll()
        clearTimeout(timeObj)
        if (res.data.msg) {
          Message.error(res.data.msg) //错误处理
        } else {
          Message.error(&#39;网络请求出错&#39;) //错误处理
        }
        return
      }
    })
}

//字符串的16进制表达
function strToHexCharCode(_str: string) {
  if (_str === &#39;&#39;) return &#39;&#39;
  var hexCharCode: Array&amp;lt;string&amp;gt; = []
  for (var i = 0; i &amp;lt; _str.length; i++) {
    var str = _str.charCodeAt(i).toString(16)
    if (_str.length == 1) str += &#39;0&#39; + _str
    hexCharCode.push(str)
  }
  return hexCharCode.join(&#39;&#39;)
}

let requestCount = 0
let timeObj: NodeJS.Timeout
// http request 拦截器
axios.interceptors.request.use((config) =&amp;gt; {
  requestCount++
  if (requestCount == 1) {
    timeObj = setTimeout(() =&amp;gt; {
      Message.info({ message: &#39;加载中...&#39;, duration: 0 })
    }, 800)
  }

  if (
    config.data &amp;amp;&amp;amp;
    Object.prototype.toString.call(config.data) == &#39;[object FormData]&#39;
  ) {
    config.headers!![&#39;Content-Type&#39;] = &#39;multipart/form-data;charset=utf-8&#39;
    config.transformRequest = [
      function (data) {
        return data
      },
    ]
  }

  if (localStorage.getItem(&#39;currentRole&#39;)) {
    ;(config.headers as AxiosRequestHeaders)[&#39;currentRole&#39;] =
      localStorage.getItem(&#39;currentRole&#39;)
  }
  return config
})

// http response 拦截器
axios.interceptors.response.use((response) =&amp;gt; {
  requestCount--
  if (requestCount === 0) {
    setTimeout(() =&amp;gt; {
      Message.closeAll()
    }, 1500)
    clearTimeout(timeObj)
  }
  return response
})
// axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39;;
// axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/json; charset=utf-8&#39;;
// axios.defaults.withCredentials = true

// 返回在vue模板中的调用接口
export default {
  get: function (
    url: string,
    params: string | object | null,
    success: any,
    failure: any
  ) {
    return apiAxios(&#39;GET&#39;, url, params, success, failure)
  },
  post: function (
    url: string,
    params: string | object,
    success: any,
    failure: any
  ) {
    return apiAxios(&#39;POST&#39;, url, params, success, failure)
  },
  put: function (
    url: string,
    params: string | object,
    success: any,
    failure: any
  ) {
    return apiAxios(&#39;PUT&#39;, url, params, success, failure)
  },
  delete: function (
    url: string,
    params: string | object,
    success: any,
    failure: any
  ) {
    return apiAxios(&#39;DELETE&#39;, url, params, success, failure)
  },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同时新建一个&lt;code&gt;src/api/index.ts&lt;/code&gt;，主要用来抛出定义的接口名称，算是按需加载吧&lt;br&gt;
另外，有很多时候前端项目需要部署到很多服务器上，接口的域名会改变，所以做一个动态改变配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// 导出接口配置文件
import conf from &#39;@/assets/config/host.config&#39;
let BaseUrl = conf.serviceHost + &#39;/api&#39;
export const GetUserInfo = `${BaseUrl}/user/GetUserInfo`
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;动态配置文件加载&#34;&gt;动态配置文件加载&lt;/h3&gt;
&lt;p&gt;新建&lt;code&gt;src/config/host.config.ts&lt;/code&gt;，然后在&lt;code&gt;main.ts&lt;/code&gt;中引入它。最后需要在index.html中引入一个&lt;code&gt;&amp;lt;script src=&amp;quot;./config/index.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;,在第一次部署的时候加一个这个文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// src/config/host.config.ts
let config = {
  serviceHost: &#39;http://basedebug.bestsch.com/mission2p6&#39;,

  ssoHost: &#39;http://ssodebug.bestsch.com&#39;,
  baseHost: &#39;http://basedebug.bestsch.com&#39;,
}
if (typeof (window as any).conf !== &#39;undefined&#39;) config = (window as any).conf
export default config
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// ./config/index.js
window.conf = {
  serviceHost: &amp;quot;http://basedebug.bestsch.com/mission2p6&amp;quot;,
  ssoHost: &amp;quot;http://ssodebug.bestsch.com&amp;quot;,
  baseHost: &amp;quot;http://basedebug.bestsch.com&amp;quot;,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样以后如果域名什么的修改了，就不用手动打包再上传了。也可以定义自己的配置，动态修改。&lt;/p&gt;
&lt;h3 id=&#34;如何使用&#34;&gt;如何使用&lt;/h3&gt;
&lt;p&gt;写好的&lt;code&gt;my-axios.ts&lt;/code&gt;配置文件在需要的文件中引入就可以了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;&amp;lt;script setup lang=&amp;quot;ts&amp;quot;&amp;gt;
import api from &#39;@/assets/js/myaxios&#39;
import {
  GetXXXX,
} from &#39;@/api/index.js&#39;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装pinia&#34;&gt;安装Pinia&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm install pinia
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;mark&gt;同时为了能够数据持久化安装&lt;code&gt;pinia-plugin-persistedstate&lt;/code&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm i pinia-plugin-persistedstate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接下来我们要做一些自己的个性化设置，让代码更加有规则吧&lt;br&gt;
在&lt;code&gt;src/store/index.ts&lt;/code&gt;写入如下代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// pinia数据持久化存储
import { createPinia } from &#39;pinia&#39;
import { createPersistedState } from &#39;pinia-plugin-persistedstate&#39;
// 第一个参数是应用程序中 store 的唯一 id
const store = createPinia()
store.use(
  createPersistedState({
    serializer: {
      // 指定参数序列化器
      serialize: JSON.stringify,
      deserialize: JSON.parse,
    },
  })
)
export default store
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在main.ts中注册store以及上面编写的动态配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { createApp } from &#39;vue&#39;
import App from &#39;./App.vue&#39;
const app = createApp(App)

import config from &#39;@/assets/config/host.config.js&#39;
app.config.globalProperties.$config = config

// Pinia 持久化
import store from &#39;@/store/index&#39;
// 注册已经加上了持久化的pinia
app.use(store)
// app.use(ElementPlus);
app.mount(&#39;#app&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;这里会看到一些报错提示，&lt;mark&gt;找不到模块“./App.vue”或其相应的类型声明。&lt;/mark&gt;&lt;br&gt;
&lt;mark&gt;找不到模块“@/store/index”或其相应的类型声明。&lt;/mark&gt;&lt;br&gt;
第一个解决的方法是&lt;code&gt;src/env.d.ts&lt;/code&gt;中加入&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;/// &amp;lt;reference types=&amp;quot;vite/client&amp;quot; /&amp;gt;

declare module &#39;*.vue&#39; {
  import { DefineComponent } from &#39;vue&#39;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types
  const component: DefineComponent&amp;lt;{}, {}, any&amp;gt;
  export default component
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;第二个找不到文件的问题主要是&lt;code&gt;@&lt;/code&gt;没有被解析，ts文件不能被正确识别。&lt;br&gt;
解析&lt;code&gt;@&lt;/code&gt;在根目录下的&lt;code&gt;vite.config.js&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import path from &#39;path&#39;
import { defineConfig } from &#39;vite&#39;
.......
const pathSrc = path.resolve(__dirname, &#39;src&#39;)
......
export default defineConfig({
......
 resolve: {
    alias: {
      &amp;quot;@/&amp;quot;: `${pathSrc}/`
    }
  },
})

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;对于ts文件的识别就需要在项目根目录下新建一个&lt;code&gt;tsconfig.json&lt;/code&gt;文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;baseUrl&amp;quot;: &amp;quot;.&amp;quot;,
    &amp;quot;target&amp;quot;: &amp;quot;esnext&amp;quot;,
    &amp;quot;useDefineForClassFields&amp;quot;: true,
    &amp;quot;module&amp;quot;: &amp;quot;esnext&amp;quot;,
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;,
    &amp;quot;strict&amp;quot;: false,
    &amp;quot;jsx&amp;quot;: &amp;quot;preserve&amp;quot;,
    &amp;quot;sourceMap&amp;quot;: true,
    &amp;quot;resolveJsonModule&amp;quot;: true,
    &amp;quot;esModuleInterop&amp;quot;: true,
    &amp;quot;lib&amp;quot;: [&amp;quot;esnext&amp;quot;, &amp;quot;dom&amp;quot;],
    &amp;quot;paths&amp;quot;: {
      &amp;quot;@/*&amp;quot;: [&amp;quot;src/*&amp;quot;]
    },
    &amp;quot;skipLibCheck&amp;quot;: true
  },
  &amp;quot;include&amp;quot;: [&amp;quot;src/**/*.ts&amp;quot;, &amp;quot;src/**/*.d.ts&amp;quot;, &amp;quot;src/**/*.tsx&amp;quot;, &amp;quot;src/**/*.vue&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了上面的这个作为基础，我们就能定义自己想要的数据了，例如我定义一个存储用户信息的store&lt;br&gt;
在&lt;code&gt;src/store/user.ts&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { defineStore } from &#39;pinia&#39;
// 第一个参数是应用程序中 store 的唯一 id
export const useUserStore = defineStore(&#39;user&#39;, {
  // 其它配置项
  // persist: {
  //   // 自定义数据持久化方式
  //   // key: &#39;store-key&#39;, 指定key进行存储，此时非key的值不会持久化，刷新就会丢失
  //   storage: window.localStorage, // 指定换成地址
  //   // paths: [&#39;nested.data&#39;],// 指定需要持久化的state的路径名称
  //   beforeRestore: (context) =&amp;gt; {
  //     console.log(&#39;Before&#39; + context)
  //   },
  //   afterRestore: (context) =&amp;gt; {
  //     console.log(&#39;After&#39; + context)
  //   },
  // },
  persist: { storage: sessionStorage }, //开启数据持久化，所有store数据将被持久化到指定仓库
  state: () =&amp;gt; ({
    name: &#39;&#39;,
    age: -1,
  }),
  getters: {
    getUser() {
      return { name: this.name, age: this.age }
    },
  },
  actions: {
    setUser(user) {
      for (let i in user) {
        this[i] = user[i]
      }
    },
  },
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就可以非常简单的在需要使用的文件种导入，例如。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div&amp;gt;{{ userStore.name }}--{{ userStore.age }}&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script setup lang=&amp;quot;ts&amp;quot;&amp;gt;
import { useUserStore } from &#39;@/store/user&#39;
let userStore = useUserStore()

userStore.setUser({ name: &#39;张三&#39;, age: 22 })
&amp;lt;/script&amp;gt;

&amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装vuerouter&#34;&gt;安装VueRouter&lt;/h2&gt;
&lt;p&gt;vue3.x的对应的VueRouter版本在v4.x,如果你是vue2.x使用的路由版本在4.x会提示一些很奇怪的错误。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm install vue-router@4
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;路由注册文件&lt;br&gt;
在&lt;code&gt;/src/router/index.ts&lt;/code&gt;文件中编写自定的路由。这里主要是引入注册页面，并且希望它能够动态导入路由。目前这项功能我没使用上，不过记录一下。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { createRouter, createWebHashHistory, RouteRecordRaw } from &#39;vue-router&#39;
function getRoutes() {
  // const { routes } = loadRouters()
  const routes = [
    {
      path: &#39;/home&#39;,
      name: &#39;我的APP&#39;,
      meta: {
        title: &#39;主页&#39;,
        keepAlive: true,
      },
      component: () =&amp;gt; import(&#39;../views/teacher/home.vue&#39;),
    },
  ]
  /**
   * 如果要对 routes 做一些处理，请在这里修改
   */
  return routes
}
const router = createRouter({
  history: createWebHashHistory(),
  routes: getRoutes(),
})
// router.beforeEach((to, from, next) =&amp;gt; {
//  next()
// })
export default router

// 下面这个函数就是能自动导入指定页面下的页面， 并自动组合成上面写的router
/** 以下代码不要修改 */
function loadRouters() {
  const context = import.meta.globEager(&#39;../views/**/*.vue&#39;)
  const routes: RouteRecordRaw[] = []
  let modules = import.meta.glob(&#39;../views/**/*.vue&#39;)
  Object.keys(context).forEach((key: any) =&amp;gt; {
    if (key === &#39;./index.ts&#39;) return
    let name = key.replace(/(\.\.\/views\/|\.vue)/g, &#39;&#39;)
    let path = &#39;/&#39; + name.toLowerCase()
    if (name === &#39;Index&#39;) path = &#39;/&#39;
    routes.push({
      path: path,
      name: name,
      component: modules[`../views/${name}.vue`],
    })
  })
  return { context, routes }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;将写好的文件导入注册到&lt;code&gt;main.ts&lt;/code&gt;中&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;.......
//导入路由
import router from &#39;@/router/index&#39;
app.use(router)
......
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;那么我们就只要在APP.vue中加入&lt;code&gt;&amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;&lt;/code&gt;就能够跳转路由渲染页面了。&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// 引入useRouter
import { useRouter } from &#39;vue-router&#39;
let router = useRouter()

const toMain = () =&amp;gt; {
    router.push({ path: &#39;/home&#39; })
    }
&lt;/code&gt;&lt;/pre&gt;
这里就完成了路由的跳转配置。
&lt;h3 id=&#34;路由的灵活缓存方案&#34;&gt;路由的灵活缓存方案&lt;/h3&gt;
但是平常可能会遇到这样一个这样的场景A-&amp;gt;B，返回到A页面的时候希望保存之前的状态，A-&amp;gt;C返回的时候就重新调用函数。那么就需要一个灵活的缓存操作。而如果你使用&lt;code&gt;activated&lt;/code&gt;这种方法，你就要在URL或者什么地方记录本次是否重新调用接口，这样就显得太麻烦了。我们都了解使用&lt;code&gt;keep-alive&lt;/code&gt;能缓存组件，同时&lt;code&gt;include&lt;/code&gt;和&lt;code&gt;exclude&lt;/code&gt;能让那些组件缓存和不缓存，而且&lt;code&gt;exclude&lt;/code&gt;优先级比&lt;code&gt;include&lt;/code&gt;高。那么我是否可以通过操作这2个数组来控制是否缓存页面。&lt;br&gt;
在&lt;code&gt;/src/router/keepAlive.ts&lt;/code&gt;文件中写入以下代码&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;     import { ComponentInternalInstance, ref } from &#39;vue&#39;
     export const excludes = ref&amp;lt;string[]&amp;gt;([])
     export function removeKeepAliveCache(instance: ComponentInternalInstance) {
     excludes.value.push(instance.type.name!)
     console.log(excludes.value, &#39;remove&#39;)
     }
     export function resetKeepAliveCache(instance: ComponentInternalInstance) {
     excludes.value = excludes.value.filter((item) =&amp;gt; item !== instance.type.name)
     console.log(excludes.value, &#39;reset&#39;)
     }
     export const SimpleEvents = {
     map: new Map(),
     registerEvent(key: string, cb: (data?: any) =&amp;gt; void) {
         this.map.set(key, cb)
     },
     emit(key: string, params?: any) {
         if (this.map.has(key)) {
         this.map.get(key)(params)
         }
     },
     }
     export const GlobalData = {
     animationMode: ref(&#39;slide&#39;),
     }
&lt;/code&gt;&lt;/pre&gt;
一个简单高效的通过控制&lt;code&gt;exclude&lt;/code&gt;数组来改变是否缓存页面的方法就出现了。在APP.vue页面引入&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- App.vue --&amp;gt;
&amp;lt;template&amp;gt;
     &amp;lt;router-view v-slot=&amp;quot;{ Component, route }&amp;quot;&amp;gt;
         &amp;lt;keep-alive :include=&amp;quot;include&amp;quot; :exclude=&amp;quot;excludes&amp;quot;&amp;gt;
             &amp;lt;component :is=&amp;quot;Component&amp;quot;&amp;gt;&amp;lt;/component&amp;gt;
         &amp;lt;/keep-alive&amp;gt;
     &amp;lt;/router-view&amp;gt;
&amp;lt;/template&amp;gt;

 &amp;lt;script lang=&amp;quot;ts&amp;quot;&amp;gt;
     export default {
         name: &#39;Home&#39;
     }
 &amp;lt;/script&amp;gt; 
 &amp;lt;script lang=&amp;quot;ts&amp;quot; setup&amp;gt;
 
  import { excludes } from &#39;@/router/keepAlive&#39;
  const include = [&#39;A&#39;, &#39;B&#39;,&#39;C&#39;]
 &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当我们从A跳入C的时候我们希望C返回到A不缓存&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- A --&amp;gt;
&amp;lt;template&amp;gt;
    A页面
&amp;lt;/template&amp;gt;

 &amp;lt;script lang=&amp;quot;ts&amp;quot;&amp;gt;
     export default {
         name: &#39;A&#39;
     }
 &amp;lt;/script&amp;gt; 
 &amp;lt;script lang=&amp;quot;ts&amp;quot; setup&amp;gt;
 
 import { useRouter, onBeforeRouteLeave } from &#39;vue-router&#39;
 import { removeKeepAliveCache, resetKeepAliveCache } from &#39;@/router/keepAlive&#39;
const instance = getCurrentInstance()!
 onBeforeRouteLeave((to, from) =&amp;gt; {
     if (to.path === &#39;/C&#39;) {
         removeKeepAliveCache(instance)
     } else {
         resetKeepAliveCache(instance)
     }
 })
 &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- C --&amp;gt;
&amp;lt;template&amp;gt;
    C页面
&amp;lt;/template&amp;gt;

 &amp;lt;script lang=&amp;quot;ts&amp;quot;&amp;gt;
     export default {
         name: &#39;C&#39;
     }
 &amp;lt;/script&amp;gt; 
 &amp;lt;script lang=&amp;quot;ts&amp;quot; setup&amp;gt;
 &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt; removeKeepAliveCache, resetKeepAliveCache&lt;/code&gt;暴露的方法来控制exclude数组，从而达到是否缓存这个页面，同时还能做一些动画。这里如果有时间就去琢磨实现一下。&lt;/p&gt;
&lt;h2 id=&#34;优化&#34;&gt;优化&lt;/h2&gt;
&lt;p&gt;上面的步骤基本完成了一个项目的搭建，和一些开发时候的优化。这里做的优化是一些代码编写时候的便捷优化。Vue3比较不同的是它可以采用组合式编程，一段一段的。&lt;/p&gt;
&lt;h3 id=&#34;自动导入&#34;&gt;自动导入&lt;/h3&gt;
&lt;p&gt;由于经常要引入vue的方法，而我又不想自己手动写，想让它自动导入，这怎么弄呢&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;code&gt;unplugin-auto-import&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;npm i -D unplugin-auto-import
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vite.config.ts 配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;......
import AutoComplete from &#39;unplugin-auto-import/vite&#39;
......
const pathSrc = path.resolve(__dirname, &#39;src&#39;)
export default defineConfig({
    .....
    plugins:[
     AutoComplete({
         imports: [&#39;vue&#39;, &#39;vue-router&#39;],
         dts: path.resolve(pathSrc, &#39;auto-imports.d.ts&#39;),
         }),
    ]
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;打包优化&#34;&gt;打包优化&lt;/h3&gt;
&lt;p&gt;这个只要在vite.config.ts中配置一下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;   export default defineConfig({
         base: &#39;./&#39; /* 这个就是webpack里面的publicPath */,
         build: {
             rollupOptions: {
             output: {
                 // 最小化拆分包
                 manualChunks: (id) =&amp;gt; {
                 if (id.includes(&#39;node_modules&#39;)) {
                     return id
                     .toString()
                     .split(&#39;node_modules/&#39;)[1]
                     .split(&#39;/&#39;)[0]
                     .toString()
                 }
                 }, // 用于从入口点创建的块的打包输出格式[name]表示文件名,[hash]表示该文件内容hash值
                 entryFileNames: &#39;js/[name].[hash].js&#39;, // 用于命名代码拆分时创建的共享块的输出命名
                 chunkFileNames: &#39;js/[name].[hash].js&#39;, // 用于输出静态资源的命名，[ext]表示文件扩展名
                 // assetFileNames: &#39;[ext]/[name].[hash].[ext]&#39;, // 拆分js到模块文件夹 // chunkFileNames: (chunkInfo) =&amp;gt; { //     const facadeModuleId = chunkInfo.facadeModuleId ? chunkInfo.facadeModuleId.split(&#39;/&#39;) : []; //     const fileName = facadeModuleId[facadeModuleId.length - 2] || &#39;[name]&#39;; //     return `js/${fileName}/[name].[hash].js`; // },
             },
             },
         },
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后可能有其他的优化我暂时记不起来了，把整个配置文件分享出来，以后想起来了，再接着编写&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;     import path from &#39;path&#39;
     import { defineConfig } from &#39;vite&#39;
     import vue from &#39;@vitejs/plugin-vue&#39;
     import Components from &#39;unplugin-vue-components/vite&#39;
     import { ElementPlusResolver } from &#39;unplugin-vue-components/resolvers&#39;
     import ElementPlus from &#39;unplugin-element-plus/vite&#39;
     import Icons from &#39;unplugin-icons/vite&#39;
     import IconsResolver from &#39;unplugin-icons/resolver&#39;
     import AutoImport from &#39;unplugin-auto-import/vite&#39;
     import { splitVendorChunkPlugin } from &#39;vite&#39;
     import Unocss from &#39;unocss/vite&#39;
     import {
     presetAttributify,
     presetIcons,
     presetUno,
     transformerDirectives,
     transformerVariantGroup,
     } from &#39;unocss&#39;
     const pathSrc = path.resolve(__dirname, &#39;src&#39;)
     // https://vitejs.dev/config/
     export default defineConfig({
     base: &#39;./&#39; /* 这个就是webpack里面的publicPath */,
     build: {
         rollupOptions: {
         output: {
             // 最小化拆分包
             manualChunks: (id) =&amp;gt; {
             if (id.includes(&#39;node_modules&#39;)) {
                 return id
                 .toString()
                 .split(&#39;node_modules/&#39;)[1]
                 .split(&#39;/&#39;)[0]
                 .toString()
             }
             }, // 用于从入口点创建的块的打包输出格式[name]表示文件名,[hash]表示该文件内容hash值
             entryFileNames: &#39;js/[name].[hash].js&#39;, // 用于命名代码拆分时创建的共享块的输出命名
             chunkFileNames: &#39;js/[name].[hash].js&#39;, // 用于输出静态资源的命名，[ext]表示文件扩展名
             // assetFileNames: &#39;[ext]/[name].[hash].[ext]&#39;, // 拆分js到模块文件夹 // chunkFileNames: (chunkInfo) =&amp;gt; { //     const facadeModuleId = chunkInfo.facadeModuleId ? chunkInfo.facadeModuleId.split(&#39;/&#39;) : []; //     const fileName = facadeModuleId[facadeModuleId.length - 2] || &#39;[name]&#39;; //     return `js/${fileName}/[name].[hash].js`; // },
         },
         },
     },
     resolve: {
         alias: {
         &#39;@/&#39;: `${pathSrc}/`,
         },
     },
     css: {
         preprocessorOptions: {
         scss: {
             additionalData: `@use &amp;quot;@/styles/element/index.scss&amp;quot; as *;`,
         },
         },
     },
     plugins: [
         vue(),
         AutoImport({
         // Auto import functions from Vue, e.g. ref, reactive, toRef...
         // 自动导入 Vue 相关函数，如：ref, reactive, toRef 等
         imports: [&#39;vue&#39;],
         // Auto import functions from Element Plus, e.g. ElMessage, ElMessageBox... (with style)
         // 自动导入 Element Plus 相关函数，如：ElMessage, ElMessageBox... (带样式)
         resolvers: [
             ElementPlusResolver(),
             // Auto import icon components
             // 自动导入图标组件
             IconsResolver({
             prefix: &#39;Icon&#39;,
             }),
         ],
         dts: path.resolve(pathSrc, &#39;auto-imports.d.ts&#39;),
         }),
         Components({
         // allow auto load markdown components under `./src/components/`
         extensions: [&#39;vue&#39;, &#39;md&#39;],
         // allow auto import and register components used in markdown
         include: [/\.vue$/, /\.vue\?vue/, /\.md$/],
         resolvers: [
             ElementPlusResolver({
             importStyle: &#39;sass&#39;,
             }),
             // Auto register icon components
             // 自动注册图标组件
             IconsResolver({
             enabledCollections: [&#39;ep&#39;],
             }),
         ],
         dts: path.resolve(pathSrc, &#39;components.d.ts&#39;),
         }),
         // https://github.com/antfu/unocss
         // see unocss.config.ts for config
         Unocss({
         presets: [
             presetUno(),
             presetAttributify(),
             presetIcons({
             scale: 1.2,
             warn: true,
             }),
         ],
         transformers: [transformerDirectives(), transformerVariantGroup()],
         }),
         splitVendorChunkPlugin(),
         Icons({
         autoInstall: true,
         }),
         ElementPlus({
         // options
         }),
     ],
     server: {
         proxy: {
         // 字符串简写写法
         // &#39;/foo&#39;: &#39;http://localhost:4567&#39;,
         // 选项写法
         &#39;/api&#39;: {
             target: &#39;http://basedebug.bestsch.com/mission2p6&#39;,
             changeOrigin: true,
             rewrite: (path) =&amp;gt; path.replace(/^\/api/, &#39;&#39;),
         },
         // 正则表达式写法
         // &#39;^/fallback/.*&#39;: {
         //   target: &#39;http://jsonplaceholder.typicode.com&#39;,
         //   changeOrigin: true,
         //   rewrite: (path) =&amp;gt; path.replace(/^\/fallback/, &#39;&#39;)
         // },
         // 使用 proxy 实例
         // &#39;/api&#39;: {
         //   target: &#39;http://jsonplaceholder.typicode.com&#39;,
         //   changeOrigin: true,
         //   configure: (proxy, options) =&amp;gt; {
         //     // proxy 是 &#39;http-proxy&#39; 的实例
         //   }
         // },
         // Proxying websockets or socket.io
         // &#39;/socket.io&#39;: {
         //   target: &#39;ws://localhost:3000&#39;,
         //   ws: true
         // }
         },
     },
     })
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
">Vue3 + Vite + Ts + Axios + Pinia + VueRouter 配置教程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/VMi--Ka_h/"" data-c="
          &lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;
&lt;p&gt;在日常工作和学习中，会遇到多人开发项目。那么项目之间的合并就是一个大问题。多人开发采用git管理代码，如果没有一个好的git工作流程就会导致项目维护巨难受。凑齐之前看到一个大佬的视频，介绍了一套git上多人开发的工作流程。总结(copy)了一下。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;操作流程&#34;&gt;操作流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;git clone // 到本地&lt;/li&gt;
&lt;li&gt;git checkout -b xxx 切换至新分支xxx&lt;br&gt;
（相当于复制了remote的仓库到本地的xxx分支上&lt;/li&gt;
&lt;li&gt;修改或者添加本地代码（部署在硬盘的源文件上）&lt;/li&gt;
&lt;li&gt;git diff 查看自己对代码做出的改变&lt;/li&gt;
&lt;li&gt;git add 上传更新后的代码至暂存区&lt;/li&gt;
&lt;li&gt;git commit 可以将暂存区里更新后的代码更新到本地git&lt;/li&gt;
&lt;li&gt;git push origin xxx 将本地的xxxgit分支上传至github上的git&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;(如果在写自己的代码过程中发现远端GitHub上代码出现改变)&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;git checkout main 切换回main分支&lt;/li&gt;
&lt;li&gt;git pull origin master(main) 将远端修改过的代码再更新到本地&lt;/li&gt;
&lt;li&gt;git checkout xxx 回到xxx分支&lt;/li&gt;
&lt;li&gt;git rebase main 我在xxx分支上，先把main移过来，然后根据我的commit来修改成新的内容（中途可能会出现，rebase conflict -----》手动选择保留哪段代码）&lt;/li&gt;
&lt;li&gt;git push -f origin xxx 把rebase后并且更新过的代码再push到远端github上（-f ---》强行）&lt;/li&gt;
&lt;li&gt;原项目主人采用pull request 中的 squash and merge 合并所有不同的commit&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;远端完成更新后&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;git branch -d xxx 删除本地的git分支&lt;/li&gt;
&lt;li&gt;git pull origin master 再把远端的最新代码拉至本地&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;名词解释&#34;&gt;名词解释&lt;/h2&gt;
&lt;p&gt;git新手，百度并整理了下视频里出现的指令及含义，如有错误欢迎指正。&lt;/p&gt;
&lt;p&gt;git checkout -b xxx：git checkout xxx是指切换到xxx（用local区的xxx替换disk区文件），-b意味着branch，即创建新分支，这条指令合起来意思是创建并切换到xxx。&lt;/p&gt;
&lt;p&gt;git diff：查看暂存区与disk区文件的差异。&lt;/p&gt;
&lt;p&gt;git add xxx：将xxx文件添加到暂存区。&lt;/p&gt;
&lt;p&gt;git commit：将暂存区内容添加到local区的当前分支中。&lt;/p&gt;
&lt;p&gt;git push &lt;RemoteHostName&gt; &lt;LocalBranchName&gt;：将local区的LocalBranchName分支推送到RemoteHostName主机的同名分支。（若加-f表示无视本地与远程分支的差异强行push）&lt;/p&gt;
&lt;p&gt;git pull &lt;RemoteHostName&gt; &lt;RemoteBranchName&gt;：同上，不过改成从远程主机下载远程分支并与本地同名分支合并。&lt;/p&gt;
&lt;p&gt;git rebase xxx：假设当前分支与xxx分支存在共同部分common，该指令用xxx分支包括common在内的整体替换当前分支的common部分（原先xxx分支内容为common-&amp;gt;diversityA，当前分支内容为common-&amp;gt;diversityB，执行完该指令后当前分支内容为common-&amp;gt;diversityA-&amp;gt;diversityB）。&lt;/p&gt;
&lt;p&gt;git branch -D xxx：不加-D表示创建新local分支xxx，加-D表示强制删除local分支xxx。&lt;/p&gt;
">Git工作流程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/kE26UPIIR/"" data-c="
          &lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;
&lt;p&gt;git的服务器在国外，导致正常拉github项目会很慢，还有可能会超时。所以需要一个科学上网软件，设置代理端口。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;需求环境&#34;&gt;需求环境&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;代理软件&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1664332333229.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
我使用的是qv2ray代理，查看一下你的代理端口。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;平台设置&#34;&gt;平台设置&lt;/h2&gt;
&lt;h3 id=&#34;mac设置&#34;&gt;Mac设置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;打开终端，输入下面的指令&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global http.proxy &#39;socks5://127.0.0.1:1089&#39;
git config --global https.proxy &#39;socks5://127.0.0.1:1089&#39;
&lt;/code&gt;&lt;/pre&gt;
">Git设置代理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/F5UTvYi1N/"" data-c="
          &lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;
&lt;p&gt;一直以来家里的旧电脑闲置着，偶尔也会搞一下Linux系统。但是由于知识匮乏每次重新安装Linux系统很麻烦，就思考为啥不能像服务器运营商一样，每次重新安装系统就重置一下就好了。找了很久发现了Proxmox这个基于debian制作的虚拟机系统。如何安装查看我以往的文章，或许可以给你提供一些帮助。&lt;br&gt;
&lt;a href=&#34;https://micromatrix.gq/VL2F9qU_1/&#34;&gt;笔记本安装proxmox &lt;/a&gt;&lt;br&gt;
长久以来玩这个系统，看见很多人弄All in one和单臂路由。但是由于人在外面工作，服务器在老家，所以先折腾如何安装openwrt系统，至于网络的问题等回家再做研究。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;h3 id=&#34;我的环境&#34;&gt;我的环境&lt;/h3&gt;
&lt;p&gt;PVE版本:7.1-10&lt;/p&gt;
&lt;h3 id=&#34;下载镜像&#34;&gt;下载镜像&lt;/h3&gt;
&lt;p&gt;我这里用的是官方的原生x86镜像:&lt;br&gt;
&lt;a href=&#34;https://downloads.openwrt.org/releases/21.02.3/targets/x86/64/openwrt-21.02.3-x86-64-generic-ext4-combined-efi.img.gz&#34;&gt;https://downloads.openwrt.org/releases/21.02.3/targets/x86/64/openwrt-21.02.3-x86-64-generic-ext4-combined-efi.img.gz&lt;/a&gt;。&lt;br&gt;
你也可以自己去opwrt官网下载。例如:&lt;br&gt;
&lt;a href=&#34;https://downloads.openwrt.org/releases/22.03.0/targets/x86/64/&#34;&gt;https://downloads.openwrt.org/releases/22.03.0/targets/x86/64/&lt;/a&gt;&lt;br&gt;
选择你自己对应的服务器架构的镜像。&lt;br&gt;
或者你也可以下载别人封装好的.vmdk镜像&lt;br&gt;
&lt;a href=&#34;https://www.zerchin.xyz/2020/07/26/pve%E5%AE%89%E8%A3%85openwrt%20lede%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/#:~:text=squashfs%2Dcombined.vmdk-,%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80,-%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;wget https://downloads.openwrt.org/releases/21.02.3/targets/x86/64/openwrt-21.02.3-x86-64-generic-ext4-combined-efi.img.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解压&#34;&gt;解压&lt;/h3&gt;
&lt;p&gt;你可能需要安装gzip来解压gz压缩包&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;apt install gzip
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;gunzip openwrt-21.02.3-x86-64-generic-ext4-combined-efi.img.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后这个先放在一边，等下需要用到，别切换目录，如果切换了后面的要记住位置在哪里。&lt;/p&gt;
&lt;h3 id=&#34;创建虚拟机&#34;&gt;创建虚拟机&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;填写虚拟机名称&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663120246822.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;选择不适用任何介质&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663120276018.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;默认需要选择一个硬盘，随便设置就好，后面用不到这个硬盘&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663120333620.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;设置2核一般就够用了&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663120362710.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;设置1024M（1G）内存&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663120366756.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;选择默认的vmbr0网桥&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663120371634.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;最后确认无误后，创建虚拟机&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663120415445.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;导入刚刚下载的固件镜像&#34;&gt;导入刚刚下载的固件镜像&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;登录pve后台，执行qm importdisk命令导入刚刚下载的固件镜像&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; qm importdisk 101 openwrt-21.02.3-x86-64-generic-ext4-combined-efi.img local-lvm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;101&lt;/strong&gt;是刚刚创建的虚拟机的ID&lt;br&gt;
&lt;strong&gt;openwrt-21.02.3-x86-64-generic-ext4-combined-efi.img&lt;/strong&gt;是镜像位置&lt;br&gt;
&lt;strong&gt;local-lvm&lt;/strong&gt;是对应的存储名称，可以通过pvesm status查看可用的存储，或者直接在web上查看&lt;br&gt;
如果你使用了一些大佬的封装好的.vmdk虚拟镜像&lt;br&gt;
那么你的命令就是这样&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;qm importdisk 124 openwrt-koolshare-mod-v2.36-r14941-67f6fa0a30-x86-64-generic-squashfs-combined.vmdk local --format vmdk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;vmdk&lt;/strong&gt;是VMware的磁盘格式&lt;br&gt;
执行该命令后，会得到如下输出，看到&lt;strong&gt;Successfully imported disk&lt;/strong&gt;就说明导入成功了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;......
transferred 114.0 MiB of 120.5 MiB (94.58%)
transferred 116.0 MiB of 120.5 MiB (96.24%)
transferred 118.0 MiB of 120.5 MiB (97.90%)
transferred 120.0 MiB of 120.5 MiB (99.56%)
transferred 120.5 MiB of 120.5 MiB (100.00%)
transferred 120.5 MiB of 120.5 MiB (100.00%)
Successfully imported disk as &#39;unused0:local-lvm:vm-101-disk-1&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;打开网页，添加之前导入的磁盘&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663120924996.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663120934756.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663120946820.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;删除CD/DVD驱动器(ide2)和硬盘(scsi0)&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663120965074.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663120973412.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663120983892.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;设置启动项&#34;&gt;设置启动项&lt;/h3&gt;
&lt;p&gt;手动设置硬盘引导启动&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663121007460.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663121016625.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;启动虚拟机&#34;&gt;启动虚拟机&lt;/h3&gt;
&lt;p&gt;如果上述步骤操作顺利，就可以启动该虚拟机了&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663121047511.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以看到控制台在加载程序&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1663121057422.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;未完待续&#34;&gt;未完待续&lt;/h2&gt;
&lt;p&gt;后面的网络设置只能放假回家弄了&lt;/p&gt;
">PVE安装Openwrt</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/double_swiper/"" data-c="
          &lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;
&lt;p&gt;随着移动端设备的普及，作为前端开发，难免会遇到图片双指放大的需求。触控设备可以直接使用手指进行交互，而且基本上都支持多点触控。所以，查阅了网上大佬的案例，编写一个vue指令，来完成双指放大图片的需求。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;缩放原理&#34;&gt;缩放原理&lt;/h2&gt;
&lt;p&gt;原理其实很简单，双指向外扩张表示放大，向内收缩表示缩小，缩放比例是通过计算双指当前的距离 / 双指上一次的距离获得的。详见下图：&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1662708995270.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
计算出缩放比例后再通过下面两种方式实现缩放。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过transform进行缩放&lt;/li&gt;
&lt;li&gt;通过修改宽高来实现缩放 主流的方法都是采用transform来实现，因为性能更好。本篇文章两种方式都会介绍，任你选择。不过在讲之前，还是要先搞懂两个数学公式以及&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/PointerEvent&#34;&gt;PointerEvent指针事件&lt;/a&gt;。因为接下来会用到。如果对PointerEvent指针事件不太熟悉的小伙伴，也可以看看这篇文章js PointerEvent指针事件简单介绍。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;两点间距离公式&#34;&gt;两点间距离公式&lt;/h2&gt;
&lt;p&gt;设两个点A、B以及坐标分别为A(x1, y1)、B(x2, y2)，则A和B两点之间的距离为：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;∣&lt;/mo&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;B&lt;/mi&gt;&lt;mo fence=&#34;true&#34;&gt;∣&lt;/mo&gt;&lt;/mrow&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msqrt&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;/msqrt&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\left | AB \right | =\sqrt{(x1-x2)^2+(y1-y2)^2} 
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05017em;&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;∣&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.24em;vertical-align:-0.25612499999999994em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord sqrt&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.983875em;&#34;&gt;&lt;span class=&#34;svg-align&#34; style=&#34;top:-3.2em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.2em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34; style=&#34;padding-left:1em;&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.740108em;&#34;&gt;&lt;span style=&#34;top:-2.9890000000000003em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.740108em;&#34;&gt;&lt;span style=&#34;top:-2.9890000000000003em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.9438750000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.2em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;hide-tail&#34; style=&#34;min-width:1.02em;height:1.28em;&#34;&gt;&lt;svg width=&#39;400em&#39; height=&#39;1.28em&#39; viewBox=&#39;0 0 400000 1296&#39; preserveAspectRatio=&#39;xMinYMin slice&#39;&gt;&lt;path d=&#39;M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.25612499999999994em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * 获取两点间距离
 * @param {object} a 第一个点坐标
 * @param {object} b 第二个点坐标
 * @returns
 */
function getDistance(a, b) {
    const x = a.x - b.x;
    const y = a.y - b.y;
    return Math.hypot(x, y); // Math.sqrt(x * x + y * y);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;中点坐标公式&#34;&gt;中点坐标公式&lt;/h2&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;{&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo fence=&#34;true&#34;&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;{&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;mo fence=&#34;true&#34;&gt;}&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\left \{ x,y \right \} = \left \{ \frac{x1+x2}{2}, \frac{y1+y2}{2}  \right \}  
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.40003em;vertical-align:-0.95003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.32144em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.32144em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * 获取中点坐标
 * @param {object} a 第一个点坐标
 * @param {object} b 第二个点坐标
 * @returns
 */
function getCenter(a, b) {
    const x = (a.x + b.x) / 2;
    const y = (a.y + b.y) / 2;
    return { x: x, y: y };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获取图片缩放尺寸&#34;&gt;获取图片缩放尺寸&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
 * 获取图片缩放尺寸
 * @param {number} naturalWidth 
 * @param {number} naturalHeight 
 * @param {number} maxWidth 
 * @param {number} maxHeight 
 * @returns 
 */
function getImgSize (naturalWidth, naturalHeight, maxWidth, maxHeight) {
  const imgRatio = naturalWidth / naturalHeight;
  const maxRatio = maxWidth / maxHeight;
  let width, height;
  // 如果图片实际宽高比例 &amp;gt;= 显示宽高比例
  if (imgRatio &amp;gt;= maxRatio) {
    if (naturalWidth &amp;gt; maxWidth) {
      width = maxWidth;
      height = maxWidth / naturalWidth * naturalHeight;
    } else {
      width = naturalWidth;
      height = naturalHeight;
    }
  } else {
    if (naturalHeight &amp;gt; maxHeight) {
      width = maxHeight / naturalHeight * naturalWidth;
      height = maxHeight;
    } else {
      width = naturalWidth;
      height = naturalHeight;
    }
  }
  return { width: width, height: height }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;双指缩放逻辑&#34;&gt;双指缩放逻辑&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;Vue.directive(&amp;quot;doubleswiper&amp;quot;, {
  bind: (el, binding) =&amp;gt; {
    // 全局变量
    let isPointerdown = false, // 按下标识
      pointers = [], // 触摸点数组
      point1 = { x: 0, y: 0 }, // 第一个点坐标
      point2 = { x: 0, y: 0 }, // 第二个点坐标
      diff = { x: 0, y: 0 }, // 相对于上一次pointermove移动差值
      lastPointermove = { x: 0, y: 0 }, // 用于计算diff
      lastPoint1 = { x: 0, y: 0 }, // 上一次第一个触摸点坐标
      lastPoint2 = { x: 0, y: 0 }, // 上一次第二个触摸点坐标
      lastCenter; // 上一次中心点坐标

    let result, // 图片缩放宽高
      x, // x轴偏移量
      y, // y轴偏移量
      scale = 1, // 缩放比例
      maxScale,
      minScale = 1; // 边界恢复偏移量
    let leftX = new Map(), rightX = new Map();// 左边的边界偏移，右边的边界偏移
    let lastX, lastY, lastScale;
    // 由于图片是异步加载，需要在load方法里获取naturalWidth，naturalHeight
    el.addEventListener(&#39;load&#39;, function () {
      result = getImgSize(el.naturalWidth, el.naturalHeight, window.innerWidth, window.innerHeight);
      maxScale = Math.max(Math.round(el.naturalWidth / result.width), 3);
      // 图片宽高
      el.style.width = result.width + &#39;px&#39;;
      el.style.height = result.height + &#39;px&#39;;
      // 垂直水平居中显示
      x = (window.innerWidth - result.width) * 0.5;
      y = (window.innerHeight - result.height) * 0.5;
      lastX = x;
      lastY = y;
      lastScale = scale
      el.style.transform = `translate3d(${x}px, ${y}px, 0) scale(${scale})`;
    });

    // 图片赋值需放在load回调之后，因为图片缓存后读取很快，有可能不执行load回调
    el.src = `${el.src}?time=${new Date().getTime()}`;
    // 绑定 pointerdown
    el.addEventListener(&#39;pointerdown&#39;, function (e) {
      pointers.push(e);
      point1 = { x: pointers[0].clientX, y: pointers[0].clientY };
      if (pointers.length === 1) {
        isPointerdown = true;
        el.setPointerCapture(e.pointerId);
        lastPointermove = { x: pointers[0].clientX, y: pointers[0].clientY };
      } else if (pointers.length === 2) {
        point2 = { x: pointers[1].clientX, y: pointers[1].clientY };
        lastPoint2 = { x: pointers[1].clientX, y: pointers[1].clientY };
        lastCenter = getCenter(point1, point2);
      }
      lastPoint1 = { x: pointers[0].clientX, y: pointers[0].clientY };
    });

    // 绑定 pointermove
    el.addEventListener(&#39;pointermove&#39;, function (e) {
      if (isPointerdown) {
        handlePointers(e, &#39;update&#39;);
        const current1 = { x: pointers[0].clientX, y: pointers[0].clientY };
        if (pointers.length === 1) {
          lastX = x;
          lastY = y;
          // 单指拖动查看图片
          diff.x = current1.x - lastPointermove.x;
          diff.y = current1.y - lastPointermove.y;
          lastPointermove = { x: current1.x, y: current1.y };
          x += diff.x;
          y += diff.y;
          realDistance(el, e)
          // el.style.transform = `translate3d(${x}px, ${y}px, 0) scale(${scale})`;
        } else if (pointers.length === 2) {
          lastX = x;
          lastY = y;
          lastScale = scale;

          const current2 = { x: pointers[1].clientX, y: pointers[1].clientY };
          // 计算相对于上一次移动距离比例 ratio &amp;gt; 1放大，ratio &amp;lt; 1缩小
          let ratio = getDistance(current1, current2) / getDistance(lastPoint1, lastPoint2);
          // 缩放比例
          const _scale = scale * ratio;
          if (_scale &amp;gt; maxScale) {
            scale = maxScale;
            ratio = maxScale / scale;
          } else if (_scale &amp;lt; minScale) {
            scale = minScale;
            ratio = minScale / scale;
          } else {
            scale = _scale;
          }
          // 计算当前双指中心点坐标
          const center = getCenter(current1, current2);
          // 计算图片中心偏移量，默认transform-origin: 50% 50%
          // 如果transform-origin: 30% 40%，那origin.x = (ratio - 1) * result.width * 0.3
          // origin.y = (ratio - 1) * result.height * 0.4
          // 如果通过修改宽高或使用transform缩放，但将transform-origin设置为左上角时。
          // 可以不用计算origin，因为(ratio - 1) * result.width * 0 = 0
          const origin = {
            x: (ratio - 1) * result.width * 0.5,
            y: (ratio - 1) * result.height * 0.5
          };

          // 计算偏移量，认真思考一下为什么要这样计算(带入特定的值计算一下)
          x -= (ratio - 1) * (center.x - x) - origin.x - (center.x - lastCenter.x);
          y -= (ratio - 1) * (center.y - y) - origin.y - (center.y - lastCenter.y);
          realDistance(el, e)
          // el.style.transform = `translate3d(${x}px, ${y}px, 0) scale(${scale})`;
          lastCenter = { x: center.x, y: center.y };
          lastPoint1 = { x: current1.x, y: current1.y };
          lastPoint2 = { x: current2.x, y: current2.y };
        }
      }
      e.preventDefault();
    });

    function getBoundsByElement (el) {
      const thumbAreaRect = el.getBoundingClientRect();
      return {
        x: thumbAreaRect.left,
        y: thumbAreaRect.top,
        w: thumbAreaRect.width
      };
    }
    /**
     * @description: 判断手势是滑动
     * @param {*} type  1 左移、 2 右移、3 上移、4 下移、
     * @return {*}
     * @Date: 2022-11-03 11:11:31
     * @Author: David
     */
    function distinguishSide (type) {
      let moveDistanceX = Math.abs(pointers[0].clientX - point1.x);
      let moveDistanceY = Math.abs(pointers[0].clientY - point1.y);
      let distance = Math.max(moveDistanceX, moveDistanceY)
      if ((moveDistanceX &amp;gt; moveDistanceY) &amp;amp;&amp;amp; type &amp;gt; 2) {
        return
      } else if ((moveDistanceX &amp;lt; moveDistanceY) &amp;amp;&amp;amp; type &amp;lt;= 2) {
        return
      }
      if (distance &amp;gt;= 100) {
        binding.value(type)
      }

    }
    function realDistance (el, e) {
      let { transX, transY, multiple } = getTransform(el)
      let { x: actualX, y: actualY } = getBoundsByElement(el)
      let scaleSize = { width: result.width * multiple, height: result.height * multiple }
      let parentWidth = el.offsetParent.clientWidth;
      let parentHeight = el.offsetParent.clientHeight;


      if (scaleSize.width &amp;lt;= parentWidth) {
        if ((actualX &amp;lt; 0) &amp;amp;&amp;amp; (diff.x &amp;lt; 0)) {
          // 左移动要超出左边框
          x = lastX
          distinguishSide(1)
        } else if ((actualX &amp;gt; (parentWidth - scaleSize.width)) &amp;amp;&amp;amp; (diff.x &amp;gt; 0)) {
          // 右移且超出右边框
          x = lastX
          distinguishSide(2)
        }
      } else {
        if ((actualX &amp;gt; 0) &amp;amp;&amp;amp; (diff.x &amp;gt; 0)) {
          // 放大之后向右边移动，左边的到达边界
          x = lastX
          distinguishSide(2)
        } else if (((scaleSize.width + actualX) &amp;lt; parentWidth) &amp;amp;&amp;amp; (diff.x &amp;lt; 0)) {
          // 放大之后向左边移动，右边边的到达边界
          x = lastX
          distinguishSide(1)
        }
      }

      if (scaleSize.height &amp;lt;= parentHeight) {
        if ((actualY &amp;lt; 0) &amp;amp;&amp;amp; (diff.y &amp;lt; 0)) {
          // 上移要超出上边框
          y = lastY
          distinguishSide(3)
        } else if ((actualY &amp;gt; (parentHeight - scaleSize.height)) &amp;amp;&amp;amp; (diff.y &amp;gt; 0)) {
          // 下移且超出下边框
          y = lastY
          distinguishSide(4)
        }
      } else {
        if ((actualY &amp;gt; 0) &amp;amp;&amp;amp; (diff.y &amp;gt; 0)) {
          // 放大之后向下边移动，上边的到达边界
          y = lastY
          distinguishSide(4)
        } else if (((scaleSize.height + actualY) &amp;lt; parentHeight) &amp;amp;&amp;amp; (diff.y &amp;lt; 0)) {
          // 放大之后向上边移动，下边的到达边界
          y = lastY
          distinguishSide(3)
        }
      }

      el.style.transform = `translate3d(${x}px, ${y}px, 0) scale(${scale})`;
    }


    function getTransform (DOM) {
      let arr = getComputedStyle(DOM).transform.split(&#39;,&#39;)
      return {
        transX: isNaN(+arr[arr.length - 2]) ? 0 : +arr[arr.length - 2], // 获取translateX
        transY: isNaN(+arr[arr.length - 1].split(&#39;)&#39;)[0]) ? 0 : +arr[arr.length - 1].split(&#39;)&#39;)[0], // 获取translateX
        multiple: +arr[3] // 获取图片缩放比例
      }
    }

    // 绑定 pointerup
    el.addEventListener(&#39;pointerup&#39;, function (e) {
      if (isPointerdown) {
        handlePointers(e, &#39;delete&#39;);
        if (pointers.length === 0) {
          isPointerdown = false;
        } else if (pointers.length === 1) {
          point1 = { x: pointers[0].clientX, y: pointers[0].clientY };
          lastPointermove = { x: pointers[0].clientX, y: pointers[0].clientY };
        }
      }
    });

    // 绑定 pointercancel
    el.addEventListener(&#39;pointercancel&#39;, function (e) {
      if (isPointerdown) {
        isPointerdown = false;
        pointers.length = 0;
      }
    });

    el.addEventListener(&amp;quot;wheel&amp;quot;, function (e) {
      lastX = x;
      lastY = y;
      lastScale = scale
      let ratio = 1.1;
      // 缩小
      if (e.deltaY &amp;gt; 0) {
        ratio = 1 / 1.1;
      }
      // 限制缩放倍数
      const _scale = scale * ratio;
      if (_scale &amp;gt; maxScale) {
        ratio = maxScale / scale;
        scale = maxScale;
      } else if (_scale &amp;lt; minScale) {
        ratio = minScale / scale;
        scale = minScale;
      } else {
        scale = _scale;
      }
      // 目标元素是img说明鼠标在img上，以鼠标位置为缩放中心，否则默认以图片中心点为缩放中心
      if (e.target.tagName === &#39;IMG&#39;) {
        const origin = {
          x: (ratio - 1) * result.width * 0.5,
          y: (ratio - 1) * result.height * 0.5
        };
        // 计算偏移量
        x -= (ratio - 1) * (e.clientX - x) - origin.x;
        y -= (ratio - 1) * (e.clientY - y) - origin.y;
        lastCenter = { x: e.clientX, y: e.clientY };
      }
      // el.style.transform = `translate3d(${x}px, ${y}px, 0) scale(${scale})`;
      realDistance(el, e)
      e.preventDefault();
    })

    /**
     * 更新或删除指针
     * @param {PointerEvent} e
     * @param {string} type
     */
    function handlePointers (e, type) {
      for (let i = 0; i &amp;lt; pointers.length; i++) {
        if (pointers[i].pointerId === e.pointerId) {
          if (type === &#39;update&#39;) {
            pointers[i] = e;
          } else if (type === &#39;delete&#39;) {
            pointers.splice(i, 1);
          }
        }
      }
    }
  }
}
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;注册使用&#34;&gt;注册使用&lt;/h2&gt;
&lt;p&gt;在需要缩放的图片上使用&lt;code&gt;v-doubleswiper&lt;/code&gt;就能完成图片的缩放和移动了。&lt;/p&gt;
&lt;h2 id=&#34;注意事项&#34;&gt;注意事项&lt;/h2&gt;
&lt;p&gt;由于transform书写顺序并不满足交换律，换句话说transform: translateX(300px) scale(2);和transform: scale(2) translateX(300px);是不相等的。开发时请根据相应的书写顺序做处理。详见下图：&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1662710711783.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考文章&#34;&gt;参考文章&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/7020243158529212423#heading-6&#34;&gt;https://juejin.cn/post/7020243158529212423#heading-6&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
">JS实现双指缩放</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/GJxPK4G3e/"" data-c="
          &lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;
&lt;p&gt;本篇记录vue3和vue2在实现相同的逻辑上的一些语法差异，持续更新。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;事件绑定&#34;&gt;事件绑定&lt;/h2&gt;
&lt;p&gt;在开发过程中会遇到需要定制一些video或者audio播放组件，需要用到一些原生的事件。但是vue3和vue2原生事件的绑定是不一样的。&lt;br&gt;
例如下面的音频播放组件&lt;br&gt;
vue2中只需要在mounted(组件渲染完成的时候)在获取dom元素上直接绑定事件就可以&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;
mounted(){
    this.$refs.audioRef.onloadedmetadata = (evt)=&amp;gt;{
        // 编写自己的逻辑
        xxxxx
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是在vue3中，如果你也按照这样的逻辑编写&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;let audioRef = ref()
onMounted(()=&amp;gt;{
    audioRef.value..onloadedmetadata = (evt)=&amp;gt;{
        // 编写自己的逻辑
        xxxxx
    }
})
// 上面这种事件不会触发，根本就像没有绑定一样
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以需要改成如下写法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;    &amp;lt;audio
      ref=&amp;quot;wechatVoice&amp;quot;
      :src=&amp;quot;audioSrc&amp;quot;
      v-bind=&amp;quot;{ onloadedmetadata, onended }&amp;quot;
    &amp;gt;
      Your browser does not support the
      &amp;lt;code&amp;gt;audio&amp;lt;/code&amp;gt;
      element.
    &amp;lt;/audio&amp;gt;

    &amp;lt;script lang=&amp;quot;ts&amp;quot; setup&amp;gt;
        const onloadedmetadata = (evt) =&amp;gt; {
            // 编写加载完成之后的逻辑
        }
        const onended = (evt) =&amp;gt;{
            // 编写播放完成之后的逻辑
        }
    &amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
">Vue3和Vue2的一些写法区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/DedO5Te9_/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;现在听个歌曲可费劲了，QQ音乐，虾米音乐，网易云音乐 都得安装上！之前很简单的一个事情，现在弄的这么复杂&lt;/p&gt;
&lt;p&gt;而网易云音乐相信不需要我过多的介绍大家也都知道，很多人在听歌的时候也注意到了，由于各种限制很多的音乐呈现灰色的样式，是无法播放的。如下图所示，今天就 &lt;strong&gt;带大家把灰色不能听的音乐全部变成可以正常播放的音乐&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://micromatrix.cf/post-images/1658886925256.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;!-- more --&gt;
&lt;p&gt;今天给大家分享三种方法解锁网易云灰色音乐，当然除此之外网上还有很多解锁的教程，但我还是觉得这三种方法比较简单有效。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文发布时亲测有效，大家且用且珍惜！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;搭建一个自己的节点&#34;&gt;搭建一个自己的节点&lt;/h2&gt;
&lt;p&gt;使用docker部署一个docker镜像就可以，如果你不会docker或者不了解linux服务器，那你就去搜索下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d  -e ENABLE_FLAC=true -e ENABLE_LOCAL_VIP=true  -p 70:8080 --name unblock163  --restart=always pan93412/unblock-netease-music-enhanced  -e &amp;quot;https://music.163.com&amp;quot; -f 59.111.160.195
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解锁原理&#34;&gt;解锁原理&lt;/h2&gt;
&lt;p&gt;使用网易云旧链 / QQ / 虾米 / 百度 / 酷狗 / 酷我 / 咕咪 / JOOX 音源替换变灰歌曲链接 (默认仅启用前四)&lt;/p&gt;
&lt;h3 id=&#34;解锁方法一通过软路由openwrt系统全家解锁&#34;&gt;解锁方法一：通过软路由OpenWrt系统全家解锁&lt;/h3&gt;
&lt;p&gt;OpenWrt是最常用的软路由系统，里面可以安装非常多而且实用的功能，方法一就是用其中的&lt;strong&gt;解锁网易云音乐插件&lt;/strong&gt;来实现。&lt;br&gt;
对于没有软路由的小伙伴也可以通过废旧笔记本/台式机或者虚拟机安装OpenWrt系统。关于OpenWrt系统的安装及使用方法网上有大把的教程可以学习，由于不是今天的重点，本文就不过多介绍！&lt;/p&gt;
&lt;h4 id=&#34;一-openwrt设置吧&#34;&gt;&lt;strong&gt;一、OpenWrt设置吧&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. 首先找到OpenWrt系统内的插件-解锁网易云灰色歌曲&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://micromatrix.cf/post-images/1658886972669.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;2. 在启用后面✔打勾，解锁程序选择-NodeJS版本，音源选择酷我音乐(其他音源自行尝试)，右下角点击保存并应用。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;3. 确定插件开始运行。&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1658886989497.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;二-各平台使用方法&#34;&gt;&lt;strong&gt;二、各平台使用方法&lt;/strong&gt;&lt;/h4&gt;
&lt;h5 id=&#34;1-windows系统&#34;&gt;&lt;strong&gt;1. Windows系统&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;打开网易云音乐-设置-工具-自定义代理-服务器填入OpenWrt的IP地址，端口填写5200-点击确定-现在重启即可。&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1658887012497.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
刚重启可能会提示网络错误，不用在意，直接搜索周董歌曲试试吧！&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1658887019610.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1658887025739.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;2-安卓系统&#34;&gt;&lt;strong&gt;2. 安卓系统&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;先后台退出网易云APP，然后在连接的Wifi名上按住1秒-点击修改网络-选择静态IP-把网关和下面的域名1(DNS)设置成OpenWrt的IP地址，确保手机数据流量都经过软路由。此时重新打开网易云音乐，比如搜索周董的专辑，会发现所有歌曲全部解锁可以正常播放。&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1658887033936.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;3-ios系统&#34;&gt;&lt;strong&gt;3. ios系统&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;ios系统比较特殊，需要先下载并信任CA证书才可以。&lt;br&gt;
首先用ios手机浏览器打开本页面，直接点击链接：&lt;br&gt;
&lt;strong&gt;https://raw.githubusercontent.com/nondanee/UnblockNeteaseMusic/master/ca.crt&lt;/strong&gt;&lt;br&gt;
，在弹出的对话框中点击允许下载CA证书，然后进入设置 → 通用→描述文件→安装CA证书并在设置 → 通用 → 关于本机 → 证书信任设置开启对CA证书的信任。&lt;br&gt;
然后和安卓类似，设置手机静态IP，网关和DNS同样设置成OpenWrt系统的IP地址，打开网易云音乐即可解锁！&lt;/p&gt;
&lt;h6 id=&#34;通过shadowrocket节点解锁&#34;&gt;通过ShadowRocket节点解锁&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;1、首先获取CA证书并信任方法同上&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;2、然后打开小火箭，左上角点击扫描下方二维码添加节点：&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1658887456496.jpeg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;3、来到配置文件项-添加配置-输入以下链接，下载成功后点击使用配置&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://raw.githubusercontent.com/w37fhy/QuantumultX/master/NeteaseMusic.conf&#34;&gt;https://raw.githubusercontent.com/w37fhy/QuantumultX/master/NeteaseMusic.conf&lt;/a&gt;&lt;br&gt;
&lt;strong&gt;4、来到设置项-找到UDP-取消开启转发&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;5、回到首页-选择刚才导入的节点-全局路由选择配置-打开连接即可。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;4-macos系统&#34;&gt;&lt;strong&gt;4. MacOS系统&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;同ios方式相同，安装并信任CA证书，然后设置静态IP+网关+DNS即可。&lt;br&gt;
&lt;strong&gt;安装信任证书步骤：&lt;/strong&gt;&lt;br&gt;
使用Safari浏览器打开OpenWrt后台，找到解锁网易云灰色歌曲插件，点击下载CA根证书（可能需要科学上网环境才能打开）。&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1658887116093.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在打开的页面，右键-将页面存储为..-选择保存格式为页面源码-导出文件名为.crt结尾。&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1658887123123.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
双击打开保存的CA证书-弹出询问是否添加到钥匙串-点击添加-在钥匙串中打开添加进来的证书，在信任下面的选项：使用此证书时：后面更改为-始终信任即可！&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1658887130950.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1658887136215.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;结语&#34;&gt;结语&lt;/h2&gt;
&lt;p&gt;**配置文件：**关于Quantumult X中的懒人配置以及小火箭导入的配置项，可以查看我的GitHub地址：&lt;a href=&#34;https://bit.ly/321LHCf&#34;&gt;https://bit.ly/321LHCf&lt;/a&gt;&lt;br&gt;
&lt;strong&gt;讨论交流电报群：&lt;/strong&gt;&lt;a href=&#34;https://t.me/fhyw37&#34;&gt;https://t.me/fhyw37&lt;/a&gt;&lt;/p&gt;
">三种方法解锁网易云音乐】开VIP都无法播放的灰色音乐，教你如何解锁！</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/SoYMicnwe/"" data-c="
          &lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;
&lt;p&gt;记录一个今天遇到的问题:使用axio上传文件过程中，传入formData数据，然后提示 &lt;code&gt;the request was rejected because no multipart boundary was found&lt;/code&gt;。首先，确定这个接口是可以使用的。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;如何使用axios上传文件&#34;&gt;如何使用Axios上传文件&lt;/h2&gt;
&lt;p&gt;首先需要设置Axios的headers里面的&lt;code&gt;Content-Type&lt;/code&gt;为&lt;code&gt;multipart/form-data;charset=utf-8&lt;/code&gt;。然后就是传入的数据必须为FormData数据类型。这样完成了一个初步的上传文件设置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// import axios from &amp;quot;axios&amp;quot;;
import { baseConfig, debugUser } from &amp;quot;../config/api.config&amp;quot;;
import config from &amp;quot;../config/host.config&amp;quot;;
import utils from &amp;quot;../js/utils&amp;quot;;
import { Toast } from &amp;quot;vant&amp;quot;;


// 请求发出前
axios.interceptors.request.use(async config =&amp;gt; {
  // 上传文件

  if (config.data &amp;amp;&amp;amp; Object.prototype.toString.call(config.data) == &amp;quot;[object FormData]&amp;quot;) {
    config.headers[&amp;quot;Content-Type&amp;quot;] = &amp;quot;multipart/form-data;charset=utf-8&amp;quot;
    config.transformRequest = [function (data) {
      return data
    }]
  }


  if (config.params &amp;amp;&amp;amp; typeof config.params != &amp;quot;string&amp;quot;) config.params = utils.filterNull(config.params);
  if (process.env.NODE_ENV !== &amp;quot;production&amp;quot;) {
    //如果是开发环境
    for (const key in debugUser) config.headers[key] = debugUser[key];
  }
  if (typeof bsch != &amp;quot;undefined&amp;quot;) {
    let autho = () =&amp;gt; {
      return new Promise((resolve, reject) =&amp;gt; {
        bsch.autho(resp =&amp;gt; {
          resolve(resp)
        })
      })
    }
    let resp = await autho()
    config.headers[&amp;quot;schoolId&amp;quot;] = resp.schoolId;
    config.headers[&amp;quot;roleId&amp;quot;] = resp.roleId;
    config.headers[&amp;quot;userId&amp;quot;] = resp.userId;
  }

  return config;
});

// http response 拦截器
axios.interceptors.response.use(
  response =&amp;gt; {
    let { data, status } = response;
    return handeCallback(data, status);
  },
  function axiosRetryInterceptor (err) {
    console.log(err.message);
    console.log(err.message.indexOf(&amp;quot;exceeded&amp;quot;));
    if (err.message.indexOf(&amp;quot;exceeded&amp;quot;) &amp;gt; -1) Toast.fail(&amp;quot;网络超时！&amp;quot;);
  }
);

const createApi = (url, params = null, method = &amp;quot;GET&amp;quot;) =&amp;gt; {
  method = method.toLocaleUpperCase();
  if (params == null) params = {};
  const baseConfigCopy = {
    ...baseConfig,
    url,
    method,
    data: method === &amp;quot;POST&amp;quot; || method === &amp;quot;PUT&amp;quot; ? params : null,
    params: method === &amp;quot;GET&amp;quot; || method === &amp;quot;DELETE&amp;quot; ? params : null
  };

  try {
    return axios(baseConfigCopy);
  } catch (error) {
    console.error(&amp;quot;error:&amp;quot; + error);
    return new Promise(reject =&amp;gt; reject(error));
  }

};

function createURL (url, param) {
  var paramStr = &amp;quot;&amp;quot;;
  for (let key in param) {
    if (param.hasOwnProperty(key)) {
      const element = param[key];
      var link = &amp;quot;&amp;amp;&amp;quot; + key + &amp;quot;=&amp;quot; + element;
      paramStr += link;
    }
  }
  url = url + &amp;quot;?&amp;quot; + paramStr.substr(1);
  url = encodeURI(url);
  return url.replace(&amp;quot; &amp;quot;, &amp;quot;&amp;quot;);
}


function handeCallback (resp, resCode) {

  var respStr = resp;
  if (typeof respStr === &amp;quot;string&amp;quot;) {
    respStr = respStr.replace(/(\r\n)|(\n)|(\r)/g, &amp;quot;&amp;lt;br&amp;gt;&amp;quot;);
    respStr = respStr.replace(/(\t)/g, &amp;quot;    &amp;quot;);
    respStr = respStr.replace(/☊/g, &amp;quot;&#39;&amp;quot;);
    respStr = respStr.replace(/♤/g, &amp;quot;\\&amp;quot;);
    respStr = respStr.replace(/♢/g, &amp;quot;/&amp;quot;);
    respStr = respStr.replace(/♧/g, &#39;&amp;quot;&#39;);
    try {
      resp = JSON.parse(respStr);
    } catch (error) {
      alert(&amp;quot;网络连接错误&amp;quot;);
    }
  }

  if (resCode == 200) {
    if (resp.State || resp.code === 0) {
      return resp.data;
    } else {
      throw resp.msg;
    }
  } else {
    console.error(resCode, resp);
    throw typeof resp;
  }
}

export { createApi };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你设置了header头部的信息，然后用了formData数据。在接口调用的时候提示了 &lt;code&gt;the request was rejected because no multipart boundary was found&lt;/code&gt;这个错误。&lt;/p&gt;
&lt;h3 id=&#34;原因&#34;&gt;原因&lt;/h3&gt;
&lt;p&gt;某些情况下，浏览器不会给你的Content-Type上加上boundary，那么就会提示这个错误。造成这个错误的原因也还有formData数据经过post之后被序列化了，所以在请求接口之前的拦截中加入如下代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;    config.transformRequest = [function (data) {
      return data
    }]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;官方文档中对&lt;code&gt;transformRequest&lt;/code&gt;的解释如下&lt;br&gt;
&lt;code&gt;transformRequest&lt;/code&gt; 允许在向服务器发送前，修改请求数据只能用在 &#39;PUT&#39;, &#39;POST&#39; 和 &#39;PATCH&#39; 这几个请求方法后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream&lt;/p&gt;
">Axios 上传文件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/TW4I05DKa/"" data-c="
          &lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;
&lt;p&gt;在实际开发中，经常用到h方法来实现页面，常见的组件中也有render，h这种写法。例如iview的table中&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1657336643473.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
那么h用法也有很多的多样性。例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt; h(&amp;quot;div&amp;quot;,{style:{color: &amp;quot;black&amp;quot;}})&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h(&amp;quot;div&amp;quot;,h(&#39;span&#39;))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h(&#39;div&#39;, [h(&#39;span&#39;),h(&#39;span)])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h(&amp;quot;div&amp;quot;,&amp;quot;hello&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h(&amp;quot;div&amp;quot;,null,&#39;hello&#39;,&#39;world&#39;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h(&#39;div&#39;,null, h(&#39;span&#39;))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h(&amp;quot;div&amp;quot;,{style:{color: &amp;quot;white&amp;quot;}},&#39;hello&#39;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h(&amp;quot;div&amp;quot;,hello)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h(&amp;quot;div&amp;quot;)&lt;/code&gt;&lt;br&gt;
源码中h主要是调用createVnode方法创建虚拟dom，所以主要的东西在createVnode，h就像一个提供方便创造的可能。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;编写createvnode&#34;&gt;编写createVnode&lt;/h2&gt;
&lt;p&gt;首先要明白为啥用虚拟节点而不是真实的dom。虚拟dom就是一个对象，为了用于diff算法，真实dom的属性比较多。&lt;br&gt;
其次虚拟节点的类型有很多，例如组件、元素、文本等。&lt;br&gt;
那么为了判断虚拟dom的类型，需要有一个判断类型的方法。&lt;br&gt;
在shared编写一个ShapeFlags的函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export const enum ShapeFlags {
  ELEMENT = 1, // HTML 或 SVG 标签 普通 DOM 元素
  FUNCTIONAL_COMPONENT = 1 &amp;lt;&amp;lt; 1, // 函数式组件
  STATEFUL_COMPONENT = 1 &amp;lt;&amp;lt; 2, // 普通有状态组件
  TEXT_CHILDREN = 1 &amp;lt;&amp;lt; 3, // 子节点为纯文本
  ARRAY_CHILDREN = 1 &amp;lt;&amp;lt; 4, // 子节点是数组
  SLOTS_CHILDREN = 1 &amp;lt;&amp;lt; 5, // 子节点是插槽
  TELEPORT = 1 &amp;lt;&amp;lt; 6, // Teleport
  SUSPENSE = 1 &amp;lt;&amp;lt; 7, // Supspense
  COMPONENT_SHOULD_KEEP_ALIVE = 1 &amp;lt;&amp;lt; 8, // 需要被keep-live的有状态组件
  COMPONENT_KEPT_ALIVE = 1 &amp;lt;&amp;lt; 9, //已经被keep-live的有状态组件
  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT, // 有状态组件和函数组件都是组件，用component表示
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就有了一个判断传入的孩子节点的类型判断方法了。&lt;br&gt;
为了统一代码的编写，确认孩子的类型，将孩子放在一个数组中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { isArray, isString, ShapeFlags } from &#39;@vue/shared&#39;

// 虚拟节点有很多： 组件， 元素的、 文本的
// 先写元素
export function createVnode(type, props, children = null) {
  let shapeFlag = isString(type) ? ShapeFlags.ELEMENT : 0

  // 虚拟dom就是一个对象，为了用于diff算法，真实dom的属性比较多
  const vnode = {
    // key 虚拟节点的标识
    type,
    props,
    children,
    el: null, // 虚拟节点对应的真实节点。后续diff算法
    key: props?.[&#39;key&#39;],
    __v_isVnode: true,
    shapeFlag,
  }

  if (children) {
    let type = 0
    if (isArray(children)) {
      type = ShapeFlags.ARRAY_CHILDREN
    } else {
      children = String(children)
      type = ShapeFlags.TEXT_CHILDREN
    }
    vnode.shapeFlag |= type
  }

  return vnode
}

export function isVnode(value) {
  return !!(value &amp;amp;&amp;amp; value.__v_isVnode)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了上面创建虚拟节点的方法之后,h就是一个对写法的支持划分了。&lt;br&gt;
按照上面h可以有的写法。编写自己的h方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// h 的用法
// h(&amp;quot;div&amp;quot;)
// h(&amp;quot;div&amp;quot;,hello)
// h(&amp;quot;div&amp;quot;,{style:{color: &amp;quot;white&amp;quot;}},&#39;hello&#39;)

import { isArray, isObject } from &#39;@vue/shared&#39;
import { createVnode, isVnode } from &#39;./vnode&#39;

// h(&amp;quot;div&amp;quot;,null,&#39;hello&#39;,&#39;world&#39;)
// h(&#39;div&#39;,null, h(&#39;span&#39;))

export function h(type, propsChildren?: any, children?: any) {
  // 其余的除了3个之外的肯定都是孩子
  const l = arguments.length

  // h(&amp;quot;div&amp;quot;,{style:{color: &amp;quot;black&amp;quot;}})
  // h(&amp;quot;div&amp;quot;,h(&#39;span&#39;))
  // h(&#39;div&#39;, [h(&#39;span&#39;),h(&#39;span)])
  // h(&amp;quot;div&amp;quot;,&amp;quot;hello&amp;quot;)
  if (l === 2) {
    // 为什么要将儿子包装成数组，因为元素可以循环创建。 文本不需要包装了
    if (isObject(propsChildren) &amp;amp;&amp;amp; !isArray(propsChildren)) {
      // 虚拟节点就包装成数组
      if (isVnode(propsChildren)) {
        return createVnode(type, null, [propsChildren])
      }
      return createVnode(type, propsChildren) // 属性
    } else {
      return createVnode(type, null, propsChildren) // 是数组
    }
  } else {
    if (l &amp;gt; 3) {
      children = Array.from(arguments).slice(2)
    } else if (l === 3 &amp;amp;&amp;amp; isVnode(children)) {
      children = [children]
    }
    return createVnode(type, propsChildren, children)
    // children的情况有2中 文本 / 数组
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面判断传入参数的个数来区分。同时如果就一个孩子，那么为了写法处理的统一，放入到数组中。&lt;br&gt;
所以最后就2种情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;h(&amp;quot;h1&amp;quot;,{},[])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h(&amp;quot;h1&amp;quot;,null, 文本)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
">vue3源码学习11-h方法和createVnode方法实现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/fYCUL5u2F/"" data-c="
          &lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;
&lt;p&gt;前面主要是vue的源码仿写，最主要的是vue的响应式，以及依赖收集。是一个简易版本，和官方源码还是有很多细微差别的，例如数组代理之后改变数组长度，会触发更新之类的。数组还会被收集长度这种依赖关系，以及数组的一些&lt;code&gt;splice，push，shift，unshift，pop&lt;/code&gt;这些方法重写，来完成修复一些数组在vue依赖更新中的BUG。&lt;/p&gt;
&lt;h2 id=&#34;vue-中为了解耦将逻辑分成-2-个模块&#34;&gt;Vue 中为了解耦，将逻辑分成 2 个模块&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;运行时 核心(runtime)(不依赖平台的 browsweer test 小程序 app canvas....) 靠的是虚拟 DOM&lt;/li&gt;
&lt;li&gt;针对不同平台运行时，vue 是针对浏览器平台的&lt;/li&gt;
&lt;li&gt;渲染器&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;构建自己的runtime-dom&#34;&gt;构建自己的runtime-dom&lt;/h2&gt;
&lt;p&gt;这个功能主要是为了提供一个操作dom的方法，新建一个rumtime-dom的文件夹在packages中。然后cd 到该目录下运行&lt;code&gt;pnpn init&lt;/code&gt;，生成的package.json，修改成如下 。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;@vue/runtime-dom&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;index.ts&amp;quot;,
    &amp;quot;buildOptions&amp;quot;:{
    &amp;quot;name&amp;quot;:&amp;quot;VueRuntimeDOM&amp;quot;,
    &amp;quot;formats&amp;quot;:[
      &amp;quot;global&amp;quot;,
      &amp;quot;cjs&amp;quot;,
      &amp;quot;esm-budler&amp;quot;
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改项目的package.json中dev的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &amp;quot;scripts&amp;quot;: {
    &amp;quot;test&amp;quot;: &amp;quot;echo \&amp;quot;Error: no test specified\&amp;quot; &amp;amp;&amp;amp; exit 1&amp;quot;,
    &amp;quot;dev&amp;quot;: &amp;quot;node scripts/dev.js runtime-dom -f global&amp;quot;
  },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后参考着官方的文件。创建 如下文件&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1656220916729.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在nodeOps.ts中编写需要的dom操作方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export const nodeOps = {
  // 增 删 改 查
  insert(child, parent, anchor = null) {
    parent.insertBefore(child, anchor)
  },
  remove(child) {
    const parentNode = child.parentNode
    if (parentNode) {
      parentNode.removeChild(child)
    }
  },
  setElementText(el, text) {
    el.textContent = text
  },
  setText(node, text) {
    node.nodeValue = text
  },
  querySelector(selector) {
    return document.querySelector(selector)
  },
  parentNode(node) {
    return node.parentNode
  },
  nextSibling(node) {
    return node.nextSibling
  },
  createElement(tagName) {
    return document.createElement(tagName)
  },
  createText(text) {
    return document.createTextNode(text)
  },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而patchProp.ts主要是操作样式的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export function patchProp(el, key, prevValue, nextValue) {
  // 类名 el.className
  //样式 el.style
  // events
  // 普通属性
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先打个小样，后期慢慢填充。&lt;br&gt;
而主要文件index.ts中就是将这些合并起来&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { nodeOps } from &#39;./nodeOps&#39;
import { patchProp } from &#39;./patchProp&#39;
const renerOptions = Object.assign(nodeOps, { patchProp })
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;编写runtime-dom内容&#34;&gt;编写runtime-dom内容&lt;/h2&gt;
&lt;p&gt;runtime-dom主要是提供一个虚拟dom的操作方法。前端在代码编写的过程中，要设置类名，style样式，绑定事件，还有设置普通属性。还有node自身的属性操作。例如将节点增加到指定位置，删除节点等等，这些是dom原生就有的功能，可以进一步封装使用。这里学习一下他的核心思想。&lt;br&gt;
所以runtime-dom的核心就是提供渲染器需要的options。实际上runtime-dom并未做什么事情。&lt;br&gt;
所以&lt;code&gt;patchProp.ts&lt;/code&gt;的代码编写就是这样的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// dom属性的操作api

import { patchAttr } from &#39;./modules/attr&#39;
import { patchClass } from &#39;./modules/class&#39;
import { patchEvent } from &#39;./modules/event&#39;
import { patchStyle } from &#39;./modules/style&#39;

// null 值
// 值 值
// 值 null
export function patchProp(el, key, prevValue, nextValue) {
 // 类名 el.className
 if (key === &#39;class&#39;) {
   patchClass(el, nextValue)
 } else if (key === &#39;style&#39;) {
   //样式 el.style
   patchStyle(el, prevValue, nextValue)
 } else if (/^on[^a-z]/.test(key)) {
   // events addEventListener
   patchEvent(el, key, nextValue)
 } else {
   // 普通属性 el.setAttribute(key, prevValue)
   patchAttr(el, key, nextValue)
 }

 //样式 el.style
 // events addEventListener
 // 普通属性 el.setAttribute(key, prevValue)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;传入class的时候&#34;&gt;传入class的时候&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;a&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt; ==&amp;gt; &lt;code&gt;&amp;lt;div class=&amp;quot;b&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;br&gt;
这个时候是需要被操纵的元素dom，还有最新传入的class值。这里简单的来看是不需要旧的class值的，直接覆盖新值就可以了。&lt;br&gt;
所以&lt;code&gt;modules/class.ts&lt;/code&gt;的文件就是抛出一个pathcClass函数，这个函数接受了&lt;code&gt;(el,nextValue)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export function patchClass(el, nextValue) {
  if (nextValue == null) {
    el.removeAttribute(&#39;class&#39;) // 如果不需要class了直接移除
  } else {
    el.className = nextValue
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;传入style值的时候&#34;&gt;传入style值的时候&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;div style=&amp;quot;color:red;font-size:14px;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt; ==&amp;gt; &lt;code&gt;&amp;lt;div style=&amp;quot;color:yellow&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;br&gt;
这样的操作，好像直接可以旧值覆盖新值，不用做比较。如果你是一个vue开发的话，就知道这样一种写法&lt;code&gt;&amp;lt;div :style=&amp;quot;{color:&#39;red&#39;,fontSize:&#39;14px&#39;}&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;，style可以动态的改变，作为一个对象。这样的话，如果直接覆盖，是不会识别font-size的。所以需要做一个新旧值的对比。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export function patchStyle(el, prevValue, nextValue) {
  // 样式需要比较差异
  for (let key in nextValue) {
    // 用新的直接覆盖
    el.style[key] = nextValue[key]
  }

  if (prevValue) {
    for (let key in prevValue) {
      if (nextValue[key] == null) {
        el.style[key] = null
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;传入绑定事件&#34;&gt;传入绑定事件&lt;/h3&gt;
&lt;p&gt;通常原生的JS在一个dom元素上绑定一个事件，然后换绑定另一个事件。要经历一个绑定-&amp;gt;解绑 -&amp;gt;再绑定新的事件。这样的操作十分耗费性能。而如果我们绑定一个自定义的事件，然后在里面绑定要绑定的方法，这样当要绑定的方法更换的时候，不需要重新解绑再绑定，而只需要更新要绑定的方法就行。&lt;br&gt;
所以&lt;code&gt;event.ts&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;function createInvoker(callback) {
  const invoker = (e) =&amp;gt; invoker.value()
  invoker.value = callback
  return invoker
}

export function patchEvent(el, eventName: string, nextValue) {
  // 可以先移除时间，再重新绑定事件
  // remove =&amp;gt; add event
  // 这样操作每次都要卸载再安装
  // 可以绑定一个自定义事件，然后里面调用绑定的方法
  let invokers = el._vei || (el._vei = {})

  let exits = invokers[eventName] // 先看有没有缓存过

  //如果绑定的是一个空
  if (exits &amp;amp;&amp;amp; nextValue) {
    // 已经绑定过事件了
    exits.value = nextValue
  } else {
    // onClic=&amp;gt; click
    let event = eventName.slice(2).toLowerCase()
    if (nextValue) {
      const invoker = (invokers[eventName] = createInvoker(nextValue))
      el.addEventListener(event, invoker)
    } else if (exits) {
      // 如果有老值，需要将老的绑定事件移除
      el.removeEventListener(event, exits)
      invokers[eventName] = undefined
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样第一次进入的时候是没有值的，所以el.vei是一个空对象，并且invokers也没有值，那么就不存在缓存了方法名。当进入到下一步的时候要判断传入的时候是空，这样就可以解绑对应的方法。当有值的时候，就进入到了上面说的，绑定一个自定义事件。这样el.vei中就有了一个{onClick:(e)=&amp;gt;invoker.value()}。如果你这时候绑定的是一个a方法那么就会是这样&lt;code&gt;{onClick:(e)=&amp;gt;a()}&lt;/code&gt;。这样当你要绑定成b方法的时候就变成了&lt;code&gt;{onClick:(e)=&amp;gt;b()}&lt;/code&gt;。&lt;br&gt;
这里并未细致考虑绑定多方法的问题。vue3是通过数组存储来完成。&lt;/p&gt;
&lt;h3 id=&#34;传入自定义属性&#34;&gt;传入自定义属性&lt;/h3&gt;
&lt;p&gt;简单点就是有这个自定义属性就添加，没有值就移除它。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export function patchAttr(el, key, nextValue) {
  if (nextValue) {
    el.setAttribute(key, nextValue)
  } else {
    el.removeAttribute(key)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;结尾&#34;&gt;结尾&lt;/h2&gt;
&lt;p&gt;平常在编写的时候用的都是&lt;code&gt;render&lt;/code&gt;或&lt;code&gt;h&lt;/code&gt;这样的函数，来渲染虚拟dom,而不是像文章开头一样，编写很多的api。那么为了 这样的操作,vue3d都是交由&lt;code&gt;runtime-core&lt;/code&gt;来操作。&lt;br&gt;
也就是说runtime-dom的index.ts改成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { createRenderer } from &#39;@vue/runtime-core&#39;
import { nodeOps } from &#39;./nodeOps&#39;
import { patchProp } from &#39;./patchProp&#39;
const renerOptions = Object.assign(nodeOps, { patchProp }) // domApi 属性api

export function render(vnode, container) {
  // 渲染器的创建的时候传入options
  createRenderer(renerOptions).render(vnode, container)
}
export * from &#39;@vue/runtime-core&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新建的runtime-core就有h.ts和renderer.ts的函数。&lt;br&gt;
index.ts&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export { createRenderer } from &#39;./renderer&#39;
export { h } from &#39;./h&#39;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;h.ts&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export function h() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;renderer.ts&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export function createRenderer(renerOptions) {
  const render = (vnode, container) =&amp;gt; {}
  return {
    render,
  }
}
&lt;/code&gt;&lt;/pre&gt;
">vue3源码学习10-runtime-dom实现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/i1M9iA3It/"" data-c="
          &lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;
&lt;p&gt;在页面编写中，之前都是使用reactive来包裹对象，这样对象属性的值改变，其对应的effect包裹渲染动作就会被触发。并且通常有函数解构的操作，例如&lt;code&gt;let people = reactive({name:&amp;quot;张三&amp;quot;,age:24}); let {name,age} = people;&lt;/code&gt;。如果这么结构操作的话，name和age就会变成普通的变量，那么如果在effect中使用的话，就算改变了值也不会触发回调函数。那么为了解决例如此类的需求，vue3提供了&lt;code&gt;ref、toRef、toRefs&lt;/code&gt;。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;官方中的写法探究&#34;&gt;官方中的写法探究&lt;/h2&gt;
&lt;p&gt;引入官方的包，尝试了几种简单的写法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
  &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
  &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div class=&amp;quot;&amp;quot; id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;script src=&amp;quot;./dist/reactivity.global.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script&amp;gt;
    const { reactive, effect,toRef,ref,toRefs,proxyRefs } = VueReactivity
    // let people = reactive({name:&amp;quot;张三&amp;quot;,age:99})
   let name = ref(&amp;quot;张三&amp;quot;)
   let age = ref(23)
   let people = proxyRefs({name,age})
  // let {name,age} = toRefs(people)
    effect(() =&amp;gt; {
      app.innerHTML = `${people.name}今年${people.age}岁`
    })

    setTimeout(() =&amp;gt; {
      people.name = &amp;quot;利斯&amp;quot;
    },1000)
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以用Ref包裹基础数据类型，也可以包裹引用型数据。让数据变成响应式数据，可以被effect收集，然后更新数据触发回调函数。&lt;/p&gt;
&lt;h2 id=&#34;编写ref&#34;&gt;编写Ref&lt;/h2&gt;
&lt;p&gt;首先开始编写ref.ts，ref会被传入基础数据类型和引用型数据。所以方法要判断一下数据类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { isArray, isObject } from &#39;@vue/shared&#39;
import { trackEffect, triggerEffect } from &#39;./effect&#39;
import { reactive } from &#39;./reactive&#39;
function toReactive(value){
    return isObject(value) ? reactive(value) : value
}

class RefImpl{
    public _value
    constructor(public rawValue){
        this._value = toReactive(rawValue)
    }

    get value(){
        return this._value;
    }

    set value(newValue){
        if(newValue !== this.rawValue){
            this._value = toReactive(newValue);
            this.rawValue = newValue;
        }
    }
}

function ref(value){
    return new RefImpl(value)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面是一个初步的对象包裹，但是还没加入依赖收集。现在加入&lt;a href=&#34;/KKorFw4cz/&#34;&gt;第七篇文章&lt;/a&gt;中分离的依赖收集函数和更新触发的函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;......
import { isArray, isObject } from &#39;@vue/shared&#39;
import { trackEffect, triggerEffect } from &#39;./effect&#39;
import { reactive } from &#39;./reactive&#39;
function toReactive(value){
    return isObject(value) ? reactive(value) : value
}

class RefImpl{
    public _value
    public dep = new Set()
    public __v_isRef = true
    constructor(public rawValue){
        this._value = toReactive(rawValue)
    }

    get value(){
        trackEffect(this.dep)
        return this._value;
    }

    set value(newValue){
        if(newValue !== this.rawValue){
            this._value = toReactive(newValue);
            this.rawValue = newValue;
            triggetEffect(this.dep)
        }
    }
}

function ref(value){
    return new RefImpl(value)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就完成了Ref的基本功能。现在有了包裹对象，那么就有第二中需求，结构这种需求。toRefs和toRef就是vue3提供的函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;......
class ObjectRefImpl {
  constructor(public object, public key) {}

  get value() {
    return this.object[this.key]
  }

  set value(newValue) {
    this.object[this.key] = newValue
  }
}

export function toRef(object, key) {
  return new ObjectRefImpl(object, key)
}

export function toRefs(object) {
  const result = isArray(object) ? new Array(object.length) : {}

  for (let key in object) {
    result[key] = toRef(object, key)
  }

  return result
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;toRefs就比较简单就是单个toRef的单个版本实现，所以基于toRefs就基于toRef实现就行。&lt;br&gt;
另外可以观察到vue3中Ref包裹的对象在template中使用发现不需要&lt;code&gt;xx.value&lt;/code&gt;，这是vue3官方做的一个优化，实际就像是ref包裹的反向过程。&lt;/p&gt;
&lt;h2 id=&#34;编写proxyrefs&#34;&gt;编写proxyRefs&lt;/h2&gt;
&lt;p&gt;上面知道了vue3提供了一个proxyRefs这样的函数，来使得ref对象使用更加方便了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;......
export function proxyRefs(object) {
  return new Proxy(object, {
    get(target, key, recevier) {
      let r = Reflect.get(target, key, recevier)
      return r.__v_isRef ? r.value : r
    },

    set(target, key, value, receiver) {
      let oldValue = target[key]
      if (oldValue.__v_isRef) {
        oldValue.value = value
        return true
      } else {
        return Reflect.set(target, key, value, receiver)
      }
    },
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;template模板上通常都是get数据那么就是代理对象反射这个&lt;code&gt;.value&lt;/code&gt;这样，为啥要用Reflect来反射，是因为this的指向问题。第三篇文章分析了这个问题。&lt;br&gt;
&lt;a href=&#34;https://github.com/Stonewalling/vue3-plan/tree/ref&#34;&gt;完整代码&lt;/a&gt;&lt;/p&gt;
">vue3源码学习-9-ref的实现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/h-oUk7MeM/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;本文学习编写watch功能函数。首先，先去使用下官方的watch做一些简单的小功能测试。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot; /&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot; /&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;computed&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;!-- 官方的 --&amp;gt;
    &amp;lt;script src=&amp;quot;../../node_modules/vue/dist/vue.global.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;!-- &amp;lt;script src=&amp;quot;./dist/reactivity.global.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;
    &amp;lt;script&amp;gt;
      // effect 代表的是副作用函数，如果函数依赖发生改变，他就重新执行
      // reactive 将数据变成响应式 相当于proxy
      // shallowRactive,readonly,shallowReadonly
      const { reactive, watch } = Vue
      const state = reactive({ name: &#39;jw&#39;, address: { num: 1 } })

      watch(
        state,
        (newValue, oldValue) =&amp;gt; {
          console.log(newValue, oldValue) // 数据改变触发了打印
        }
      )

      watch(
        () =&amp;gt; state.address.num,
        (newValue, oldValue) =&amp;gt; {
          console.log(newValue, oldValue) // 数据改变触发了打印
        }
      )

      watch(
        state.address.num,
        (newValue, oldValue) =&amp;gt; {
          console.log(newValue, oldValue) //  没触发打印
        }
      )

      setTimeout(() =&amp;gt; {
        state.address.num = 123
      }, 1000)
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面尝试了3中方式，结果发现第三种不触发打印，因为你监听的是数值1，一个常量就不会有改变的情况。&lt;br&gt;
另外如果你监听一个对象，例如&lt;code&gt;state.address&lt;/code&gt;这样的，那也不会触发打印。因为这个对象是引用类型，也就是在内存中的地址也没改变，你就是改变了对象属性的之，他监听不到改变。&lt;br&gt;
第二种写法是比较优的方式。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;编写watch&#34;&gt;编写watch&lt;/h2&gt;
&lt;p&gt;在上述官方的使用过程中，watch接受了2个参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户需要监听的参数，可能是函数也可能是一个reactive对象&lt;/li&gt;
&lt;li&gt;用户传入的回调函数&lt;br&gt;
当需要监听的数据改变的时候，触发回调函数。那么实际上就相当于给监听的数据的属性绑定一个effect，做一个依赖收集，这样当数据改变，就触发用户的回调函数。&lt;br&gt;
那么第一步对传入的数据做判断，如果是reacvtive就遍历数据对象，然后每个属性做依赖收集&lt;br&gt;
如果是函数的话，就不用遍历。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;function traversal(value, set = new Set()) {
  // 如果对象中有循环引用的问题 官方用Set
  if (isObject(value)) return value

  if (set.has(value)) return value
  set.add(value)

  for (let key in value) {
    traversal(value[key], set)
  }

  return value
}

export function watch(source,cb){
  let getter
  if (isReactive(source)) {
    // 对用户的传入的数据进行递归循环，只要循环就会访问对象的每一个属性，访问属性的时候就会收集effect。
    getter = () =&amp;gt; traversal(source)
  } else if (isFunction(source)) {
    getter = source
  } else {
    return
  }
  // 同时记录下新值和旧值
   let oldValue
   let cleanup
  const job = () =&amp;gt; {
    const newValue = effect.run()
    cb(newValue, oldValue, onCleanup)
    oldValue = newValue
  }
  // 在effect中属性就会被依赖收集
  const effect = new ReactiveEffect(getter, job) // 监控自己构造的函数，变化后重新执行job

  oldValue = effect.run()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这就是一个简单的watch函数。在wathc官方用法中，还遇到这样一种情况。例如input上面你输入文字然后进行接口调用搜索关键字，你输入了2个子。那么当第一个接口的延迟是2秒中之后返回数据，第二个文字接口在500毫秒返回数据。由于接口的调用是并行的。那么最终会才用第一个接口的数据，第二个比第一个快，导致被覆盖了，这是不正确的。&lt;br&gt;
正常的做法有用防抖来做，那么vue官方提供了一个onCleanup回调函数。&lt;br&gt;
当数据改变引起变化的时候，会调触发上一个watch回调的oncleanup。这样就能通过一些操作来渲染正确的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;      const { reactive, watch } = VueReactivity
      const state = reactive({ name: &#39;jw&#39;, address: { num: 1 } })
      let getMoreData = (time) =&amp;gt; {
        return new Promise((resolve, reject) =&amp;gt; {
          setTimeout(() =&amp;gt; {
            resolve(state.address.num)
          }, time)
        })
      }

      watch(
        () =&amp;gt; state.address.num,
        async (newValue, oldValue, onCleanup) =&amp;gt; {
          let clean = false
          onCleanup(() =&amp;gt; {
            clean = true
          })
          let i = Math.random() * 10000
          console.log(i)
          let text = await getMoreData(i)
          if (!clean) {
            document.getElementById(&#39;app&#39;).innerHTML = text
          }
        }
      )
      state.address.num = 456
      state.address.num = 123
      state.address.num = 678
      state.address.num = 999
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的分析，就是在触发回调函数的时候触发上一个watch中的onCleanup函数。&lt;br&gt;
对watch增加一些功能，记录一下用户的onCleanup函数内容。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { ReactiveEffect } from &#39;./effect&#39;
import { isReactive } from &#39;./reactive&#39;
import { isFunction, isObject } from &#39;@vue/shared&#39;

function traversal(value, set = new Set()) {
  // 如果对象中有循环引用的问题 官方用Set
  if (isObject(value)) return value

  if (set.has(value)) return value
  set.add(value)

  for (let key in value) {
    traversal(value[key], set)
  }

  return value
}

// source是用户传入的对象, cb 就是对应用户的回调
export function watch(source, cb) {
  let getter
  if (isReactive(source)) {
    // 对用户的传入的数据进行递归循环，只要循环就会访问对象的每一个属性，访问属性的时候就会收集effect。
    getter = () =&amp;gt; traversal(source)
  } else if (isFunction(source)) {
    getter = source
  } else {
    return
  }
  let oldValue
  let cleanup
  const onCleanup = (fn) =&amp;gt; {
    cleanup = fn // 保存用户的函数
  }

  const job = () =&amp;gt; {
    if (cleanup) cleanup() // 下一次watch开始触发上一次watch的清理
    const newValue = effect.run()
    cb(newValue, oldValue, onCleanup)
    oldValue = newValue
  }
  // 在effect中属性就会被依赖收集
  const effect = new ReactiveEffect(getter, job) // 监控自己构造的函数，变化后重新执行job

  oldValue = effect.run()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Stonewalling/vue3-plan/tree/watch&#34;&gt;完整代码&lt;/a&gt;&lt;/p&gt;
">vue3源码学习-8-watch</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/KKorFw4cz/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;回顾上期的内容，编写了effect中的调度器，主要修改了effect.ts文件。在预览之前的代码的时候会发现一些优化的地方。&lt;br&gt;
在vue代码的需求编辑中，会遇到这样一个例子。例如一个人的姓名分为姓和名，那么我希望在页面上打印出这个人的姓+名，而且在姓或者名改变的时候，页面渲染也会改变。那么就用到了vue的computed来进行操作。旧版的vue2中computed是基于watcher实现的。vue3则是基于effect来实现。另外vue3中的computed写法叫组合式API，而vue2是拿data中的属性来编写computed中的属性，这种叫选项式API(option)。具体的vue3写法如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;      const { effect, reactive, computed } = VueReactivity
      let target = { firstName: &#39;张&#39;, lastName: &#39;四&#39; }
      const state = reactive(target)
      let app = document.getElementById(&#39;app&#39;)
      const fullName = computed(() =&amp;gt; {
        console.log(&#39;runner&#39;)
        return state.firstName + state.lastName
      })
      effect(() =&amp;gt; {
        return (app.innerHTML = fullName.value)
      })

      setTimeout(() =&amp;gt; {
        state.firstName = &#39;王&#39;
      }, 1000)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以写成如下的方式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;      const fullName = computed({
          get(){
            console.log(&#39;runner&#39;)
            return state.firstName + state.lastName
          },
          set(){

          }
      })
      fullName.value;
      fullName.value;
      fullName.value;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并且在多次访问value的时候，如果值未改变就不触发运行，也就是说带有一个缓存的功能。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;basehandle功能优化&#34;&gt;baseHandle功能优化&lt;/h2&gt;
&lt;p&gt;在给属性包裹一层代理的时候，如果对象的属性还是一个对象之类的属性，那么返回的不应该只是这个值，而应该是这个对象代理之后的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;// baseHandle.ts get访问器中判断是否是对象，如果是就再代理一层
    let res = Reflect.get(target, key, recevier)
    if (isObject(res)) {
      return reactive(res) // 深度代理实现
    }
    return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;编写computed功能&#34;&gt;编写computed功能&lt;/h2&gt;
&lt;p&gt;对着上面的官方用法，知道如果只有一个函数的话，那就是这个函数默认为get，还可以有一个对象的写法，那就是将用户的set和get赋值上去。&lt;br&gt;
另外还effect中渲染了computed抛出的值，然后这个值改变了，也触发了effect的run，让他重新渲染，这说明computed是记录了effect的依赖的。&lt;br&gt;
上文说过computed是基于effect，实际上它和effect基本相等。那么就出现了effect包裹了effect这种写法。&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1655531194773.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
也就是这样传递着改变的信息，来触发页面渲染。&lt;/p&gt;
&lt;h3 id=&#34;第一步创建computedts基础&#34;&gt;第一步创建computed.ts基础&lt;/h3&gt;
&lt;p&gt;判断传递过来的式函数还是对象，然后就获取传递的get和set&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;export const computed = (getterOrOptions) =&amp;gt; {
  let onlyGetter = isFunction(getterOrOptions)
  let getter: Function, setter: Function

  if (onlyGetter) {
    getter = getterOrOptions
    setter = () =&amp;gt; {
      console.warn(&#39;no set&#39;)
    }
  } else {
    getter = getterOrOptions.get
    setter = getterOrOptions.set
  }

  return new ComputedRefImpl(getter, setter)// 将拿到的getter和setter
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;编写computedrefimpl类&#34;&gt;编写ComputedRefImpl类&lt;/h3&gt;
&lt;p&gt;这个类主要的操作是&lt;br&gt;
第一个赃值检测，就是value值多次get，然后值还没改变。&lt;br&gt;
第二个是搜集effect，这样值更新通知对应的effect进行用户的函数回调&lt;br&gt;
第三个如果不是赃值，那就运行调度函数，就是用户的操作函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;class ComputedRefImpl {
  public effect: ReactiveEffect
  public _dirty: boolean = true // ，默认应该取值的时候进行计算
  public __v_isReadonly: boolean = true
  public __v_isRef: boolean = true
  public _value: any
  public dep = new Set()
  constructor(public getter: Function, public setter: Function) {
    // 我们将用户的getter放到effect中，这里面的属性会被这个effect收集起来
    this.effect = new ReactiveEffect(getter, () =&amp;gt; {
      //稍后依赖的属性变化会执行这个调度函数

      if (!this._dirty) {
        this._dirty = true

        // 实现一个触发更新
        triggerEffect(this.dep)
      }
    })
  }

  //类的属性访问器， 底层就是Obeject.defineProperty
  get value() {
    // 做依赖收集
    trackEffect(this.dep)
    if (this._dirty) {
      this._dirty = false // 第一次取过之后的的时候才设置为false
      // 说明这个值是赃值
      this._value = this.effect.run()
    }

    return this._value
  }

  set value(newValue) {
    this.setter(newValue)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码中的triggerEffect和trackEffect是对之前的effect代码做了一个函数功能分离。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// 这不就是之前代码中的依赖收集和函数回调操作吗
export function trackEffect(dep: any) {
  if (activeEffect) {
    let shouldTrack = !dep.has(activeEffect) //一个属性多次依赖同一个effect那么去重
    if (shouldTrack) {
      dep.add(activeEffect)
      activeEffect.deps.push(dep) // 让deps记录住对应的dep，稍后在清理的地方用到
    }
  }
}

export function triggerEffect(effects) {
  effects = new Set(effects)
  effects.forEach((effect) =&amp;gt; {
    if (activeEffect !== effect) {
      if (effect.schedule) {
        effect.schedule() // 用户传入schedule的时候，就调用回调
      } else {
        effect.run() // 否则就刷新
      }
    }
    // 如果这里直接就写effect.run()，那么会遇到这种情况，在模版中赋值，那么也会触发这个，
    // 然后又通过了依赖收集的时候，运行它的第一次run（）。就会导致循环调用，爆栈，
    //所以这里需要加一个判断是否是当前的effect,如果是的话，就忽略这一次的赋值触发的run();
    //注意目前的代码是不支持异步的
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;结尾&#34;&gt;结尾&lt;/h2&gt;
&lt;p&gt;经过上面的代码编写之后就能得到一个自己的computed函数，可以试验下，发现能得到相应的效果&lt;br&gt;
&lt;a href=&#34;https://github.com/Stonewalling/vue3-plan/tree/add-computed&#34;&gt;完整代码&lt;/a&gt;&lt;/p&gt;
">vue3源码学习-7-computed的实现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/gwOC-8NUZ/"" data-c="
          &lt;h2 id=&#34;homebrew-介绍&#34;&gt;homebrew 介绍&lt;/h2&gt;
&lt;p&gt;Homebrew 是一款自由及开放源代码的软件包管理系统，用以简化 macOS 和 linux 系统上的软件安装过程。它拥有安装、卸载、更新、查看、搜索等很多实用的功能，通过简单的一条指令，就可以实现包管理，十分方便快捷。Homebrew 主要有四个部分组成: &lt;code&gt;brew&lt;/code&gt;、&lt;code&gt;homebrew-core&lt;/code&gt; 、&lt;code&gt;homebrew-bottles&lt;/code&gt;、&lt;code&gt;homebrew-cask&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;brew&lt;/td&gt;
&lt;td&gt;Homebrew 源代码仓库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;homebrew-core&lt;/td&gt;
&lt;td&gt;Homebrew 核心软件仓库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;homebrew-bottles&lt;/td&gt;
&lt;td&gt;Homebrew 预编译二进制软件包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;homebrew-cask&lt;/td&gt;
&lt;td&gt;提供 macOS 应用和大型二进制文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;设置源&#34;&gt;设置源&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看 brew.git 当前源 
$ cd &amp;quot;$(brew --repo)&amp;quot; &amp;amp;&amp;amp; git remote -v origin https://github.com/Homebrew/brew.git (fetch) origin https://github.com/Homebrew/brew.git (push) 
# 查看 homebrew-core.git 当前源
$ cd &amp;quot;$(brew --repo homebrew/core)&amp;quot; &amp;amp;&amp;amp; git remote -v origin https://github.com/Homebrew/homebrew-core.git (fetch) origin https://github.com/Homebrew/homebrew-core.git (push) 
# 修改 brew.git 为阿里源 
$ git -C &amp;quot;$(brew --repo)&amp;quot; remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git 
# 修改 homebrew-core.git 为阿里源
$ git -C &amp;quot;$(brew --repo homebrew/core)&amp;quot; remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git 
# zsh 替换 brew bintray 镜像 
$ echo &#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&#39; &amp;gt;&amp;gt; ~/.zshrc
$ source ~/.zshrc 
# bash 替换 brew bintray 镜像 
$ echo &#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles&#39; &amp;gt;&amp;gt; ~/.bash_profile $ source ~/.bash_profile 
# 刷新源 
$ brew update


# 替换清华源 
$ git -C &amp;quot;$(brew --repo)&amp;quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git 
$ git -C &amp;quot;$(brew --repo homebrew/core)&amp;quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git 
$ git -C &amp;quot;$(brew --repo homebrew/cask)&amp;quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git 
# zsh 替换 brew bintray 镜像 
$ echo &#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&#39; &amp;gt;&amp;gt; ~/.zshrc $ source ~/.zshrc 
# bash 替换 brew bintray 镜像
 $ echo &#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&#39; &amp;gt;&amp;gt; ~/.bash_profile $ source ~/.bash_profile 
# 刷新源 $ brew update

# 替换中科大 
$ git -C &amp;quot;$(brew --repo)&amp;quot; remote set-url origin https://mirrors.ustc.edu.cn/brew.git 
$ git -C &amp;quot;$(brew --repo homebrew/core)&amp;quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git 
$ git -C &amp;quot;$(brew --repo homebrew/cask)&amp;quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git 
# zsh 替换 brew bintray 镜像 
$ echo &#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#39; &amp;gt;&amp;gt; ~/.zshrc $ source ~/.zshrc 
# bash 替换 brew bintray 镜像 
$ echo &#39;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&#39; &amp;gt;&amp;gt; ~/.bash_profile $ source ~/.bash_profile 
# 刷新源 
$ brew update

# 重置 brew.git 为官方源 
$ git -C &amp;quot;$(brew --repo)&amp;quot; remote set-url origin https://github.com/Homebrew/brew.git 
# 重置 homebrew-core.git 为官方源 
$ git -C &amp;quot;$(brew --repo homebrew/core)&amp;quot; remote set-url origin https://github.com/Homebrew/homebrew-core.git # 重置 homebrew-cask.git 为官方源 
$ git -C &amp;quot;$(brew --repo homebrew/cask)&amp;quot; remote set-url origin https://github.com/Homebrew/homebrew-cask 
# zsh 注释掉 HOMEBREW_BOTTLE_DOMAIN 配置 
$ vi ~/.zshrc # export HOMEBREW_BOTTLE_DOMAIN=xxxxxxxxx 
# bash 注释掉 HOMEBREW_BOTTLE_DOMAIN 配置 
$ vi ~/.bash_profile # export HOMEBREW_BOTTLE_DOMAIN=xxxxxxxxx 
# 刷新源 
$ brew update

# 如果刷新源出错
brew update-reset
# 然后
source ~/.bash_profile 或者 ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;
">Homebrew配置国内源</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/FHUUXcYbS/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;在开发项目的过程中，偶尔会遇到很大的数据，然后设计图上又是列表还不分页的情况。为此研究了下虚拟滚动的方案。虚拟滚动大致的思路是当你往下滚动，但最后一个计算的元素出现的时候，替换上面不见了的DOM元素，将它们从渲染的HTML中剔除，同理往上滚动，一个计算的元素出现在最上面的时候，表明需要加载上面的元素信息，并隐藏下面的DOM元素。&lt;br&gt;
&lt;a href=&#34;http://htmlpreview.github.io/?https://github.com/Stonewalling/virtual-scroller/blob/main/index.html&#34;&gt;演示地址&lt;/a&gt;&lt;/p&gt;
&lt;iframe style=&#34;width:100%;height:100%;&#34; src=&#34;//htmlpreview.github.io/?https://github.com/Stonewalling/virtual-scroller/blob/main/index.html&#34;&gt;&lt;/iframe&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;具体思路&#34;&gt;具体思路&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;页面结构，当然只需要一个DIV元素就可以。然后将手动生成DOM元素添加我们需要虚拟滚动的DOM元素中。&lt;/li&gt;
&lt;li&gt;代码结构，利用JS的Class来创建一个对象，然后对象里做操作方法。这样把dom和JS操作分开，有利于代码的维护。&lt;/li&gt;
&lt;li&gt;对象上属性的考虑需要哪些呢？
&lt;ul&gt;
&lt;li&gt;需要虚拟滚动监听的dom元素 element&lt;/li&gt;
&lt;li&gt;需要虚拟滚动监听的dom的高度 height&lt;/li&gt;
&lt;li&gt;虚拟滚动列表的每一行高度 rowHeight，用来计算需要加载多少个数据&lt;/li&gt;
&lt;li&gt;新加载数据的个数 pageSize&lt;/li&gt;
&lt;li&gt;页面滚动加载新的dom元素，那么dom渲染需要时间，为此加一个缓存区域，提前渲染出需要的dom元素&lt;/li&gt;
&lt;li&gt;每一行渲染的回调函数 renderItem&lt;/li&gt;
&lt;li&gt;加载更多的回调函数 loadMore&lt;br&gt;
那么对应的html编写就是&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-html:5&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
&amp;lt;title&amp;gt;虚拟滚动&amp;lt;/title&amp;gt;
&amp;lt;!-- 一个自己的样式 --&amp;gt;
&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;./style.css&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&amp;quot;virtual-scroller&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script src=&amp;quot;./VirtualScroller.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;./index.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目前主要一个对象需要这几个属性。对应代码的编写就如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//   VirtualScroller.js
class VirtualScroller{
  constructor({
      element,
      height,
      rowHeight,
      buffer,
      renderItem,
      loadMore
  }){

  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造函数中传入需要的对象属性值，然后构造函数检验值的正确性，并赋值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//   VirtualScroller.js
class VirtualScroller{
  constructor({
      element,
      height,
      rowHeight,
      buffer,
      renderItem,
      loadMore
  }){
  if (typeof element === &#39;string&#39;) {
      this.scroller = document.querySelector(element);
      } else if (element instanceof HTMLElement) {
      this.scroller = element;
      }

      if (!this.scroller) {
      throw new Error(&#39;Invalid element&#39;);
      }

      if (!height || (typeof height !== &#39;number&#39; &amp;amp;&amp;amp; typeof height !== &#39;string&#39;)) {
      throw new Error(&#39;invalid height value&#39;);
      }

      if (!rowHeight || typeof rowHeight !== &#39;number&#39;) {
      throw new Error(&#39;rowHeight should be a number&#39;);
      }

      if (typeof renderItem !== &#39;function&#39;) {
      throw new Error(&#39;renderItem is not a function&#39;);
      }

      if (typeof loadMore !== &#39;function&#39;) {
      throw new Error(&#39;renderItem is not a function&#39;);
      }

      // set props
      this.height = height;
      this.rowHeight = rowHeight;
      this.pageSize = typeof pageSize === &#39;number&#39; &amp;amp;&amp;amp; pageSize &amp;gt; 0 ? pageSize : 50;
      this.buffer = typeof buffer === &#39;number&#39; &amp;amp;&amp;amp; buffer &amp;gt;= 0 ? buffer : 10;
      this.renderItem = renderItem;
      this.loadMore = loadMore;
      this.data = [];


  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候来看看如何生成一个对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//   index.js

let scroller = new VirtualScroller({
element: &#39;#virtual-scroller&#39;,
height: &#39;100vh&#39;,
rowHeight: 60, // px
pageSize: 100,
buffer: 10,
renderItem: function (dataItem) {
  const div = document.createElement(&#39;div&#39;);
  div.classList.add(&#39;row-content&#39;);
  div.textContent = dataItem;
  return div;
},
loadMore: function (pageSize) {
  const data = [];
  for (let i = 0; i &amp;lt; pageSize; i++) {
    const dataItem = `当前元素下标${this.data.length + i}`;
    data.push(dataItem);
  }
  return data;
}
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;赋值操作弄好之后，还需要再每次创建新对象的时候就创建一个dom元素来包裹渲染rowItem&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;constructor(){
    ......
      // 每次创建新的对象的时候就创建一个dom元素来包裹渲染rowItem
      const contentBox = document.createElement(&#39;div&#39;);
      this.contentBox = contentBox;
      this.scroller.append(contentBox);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还需要每次新建对象的的时候先渲染一批数据，然后还要再上面创建的包裹层中添加滚动监听。相当于虚拟dom的根节点。然后挂载到需要的dom节点上。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;constructor(){
  ......
  this.#loadInitData();
  this.scroller.addEventListener(&#39;scroll&#39;, throttle(this.#handleScroll, 150));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里就遇到了2个函数一个初始化加载函数，渲染第一次渲染的数据，第二个是防抖函数用来处理滚动的性能，第三个就是每次滚动到指定位置就渲染的数据的渲染函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class VirtualScroller{
  ......
#loadInitData () {
  // 拿到被挂载的dom元素，获取它的显示高度，然后看最少需要渲染多少个数据，然后把个数放入到回调函数中获取数据
  const scrollerRect = this.scroller.getBoundingClientRect();
  const minCount = Math.ceil(scrollerRect.height / this.rowHeight);
  // const page = Math.ceil(minCount / this.pageSize);
  // const newData = this.loadMore(page * this.pageSize);
  // const page = Math.ceil(minCount / this.pageSize);
  const newData = this.loadMore(minCount);
  this.data.push(...newData);
  // 拿到了数据之后就是渲染挂载到指定的contentBox容器上。
  this.#renderNewData(newData);
}

//渲染每一行，把它包裹在一个div中，并且这个dom元素也可以设置一些数据还不干扰到renderItem渲染的dom
#renderRow (item) {
  const rowContent = this.renderItem(item);
  const row = document.createElement(&#39;div&#39;);
  row.dataset.index = item
  row.style.height = this.rowHeight + &#39;px&#39;;
  row.appendChild(rowContent)
  return row;
}

#renderNewData (newData) {
  newData.forEach(item =&amp;gt; {
    this.contentBox.append(this.#renderRow(item));
  });
}

#handleScroll = (e) =&amp;gt; {
  const { clientHeight, scrollHeight, scrollTop } = e.target;
  if (scrollHeight - (clientHeight + scrollHeight) &amp;lt; 40) {
    // 到底加载更多

    const newData = this.loadMore(this.pageSize);
    this.data.push(...newData)
  }
  //记录当前的滚动距离，然后对比上一次保存的距离，知道了向上滚动还是向下滚动
  const direction = scrollTop &amp;gt; this.#scrollTop ? 1 : -1

  
  this.#toggleTopItems(direction)
  this.#toggleBottomItems(direction)

  this.#scrollTop = scrollTop;
}

  //替换上面的dom
#toggleTopItems = (direction) =&amp;gt; {
  const { scrollTop } = this.scroller;
  const firstVisibleItemIndex = Math.floor(scrollTop / this.rowHeight);
  const firstExistingItemIndex = Math.max(0, firstVisibleItemIndex - this.buffer);
  const rows = this.contentBox.children;
  // 替换上面不可见的元素
  if (direction === 1) {
    for (let i = this.#topHiddenCount; i &amp;lt; firstExistingItemIndex; i++) {
      if (rows[0]) rows[0].remove();
    }
  }
  // 恢复上面隐藏的元素
  if (direction === -1) {
    for (let i = this.#topHiddenCount - 1; i &amp;gt;= firstExistingItemIndex; i--) {
      const item = this.data[i];
      const row = this.#renderRow(item);
      this.contentBox.prepend(row);
    }
  }
  this.#topHiddenCount = firstExistingItemIndex;
  this.#paddingTop = this.#topHiddenCount * this.rowHeight;
  this.contentBox.style.paddingTop = this.#paddingTop + &#39;px&#39;;
}

//替换下面的dom
#toggleBottomItems = (direction) =&amp;gt; {
  const { scrollTop, clientHeight } = this.scroller;
  const lastVisibleItemIndex = Math.floor((scrollTop + clientHeight) / this.rowHeight);
  const lastExistingItemIndex = lastVisibleItemIndex + this.buffer;
  this.#lastVisibleItemIndex = lastVisibleItemIndex;
  const rows = [...this.contentBox.children];
  // 替换下面不可见的元素
  if (direction === -1) {
    for (let i = lastExistingItemIndex + 1; i &amp;lt;= this.data.length; i++) {
      const row = rows[i - this.#topHiddenCount];
      if (row) row.remove();
    }
  }
  // 恢复下面不可见的元素
  if (direction === 1) {
    for (let i = this.#topHiddenCount + rows.length; i &amp;lt;= lastExistingItemIndex; i++) {
      const item = this.data[i];
      if (!item) break;
      const row = this.#renderRow(item);
      this.contentBox.append(row);
    }
  }
  this.#bottomHiddenCount = Math.max(0, this.data.length - (this.#topHiddenCount + this.contentBox.children.length) - this.buffer);
  this.#paddingBottom = this.#bottomHiddenCount * this.rowHeight;
  this.contentBox.style.paddingBottom = this.#paddingBottom + &#39;px&#39;;
}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最主要的函数操作是&lt;code&gt;this.#toggleTopItems(direction); this.#toggleBottomItems(direction)&lt;/code&gt;这2个函数，他们主要就是替换消失在屏幕展示区域中的dom元素。是代码的核心。&lt;/p&gt;
">原生JS编写虚拟滚动</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/TzljAfa-h/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;经过第5章对于分支切换的操作之后，vue的effect源码就具有了收集需要的依赖，对于改变不必要的数据，不会触发依赖的更新。那么今天就要实现vue3的调度器代码，之前effect只能同步运行代码，无法对于异步操作进行数据更新。&lt;br&gt;
官方的写法是什么样子呢?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;    let flag = false;
    let runner = effect(() =&amp;gt; {
      document.getElementById(&amp;quot;app&amp;quot;).innerHTML = &amp;quot;年龄:&amp;quot;+state.age 
    },{
      schedule(){
      if(!flag){
        flag = true;
        setTimeout(() =&amp;gt; {
          runner();
          flag = false;
        },1000)
      }
    }}
    )
    // runner.effect.stop();
    state.age = 1000;
    state.age = 2000;
    state.age = 3000;
    state.age = 4000;
    state.age = 5000;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;p&gt;上面的代码最后只会渲染stage.age=5000这个样子。并且还具有了可以手动停止依赖的触发的操作&lt;code&gt;stop()&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;编写stop函数&#34;&gt;编写stop()函数&lt;/h2&gt;
&lt;p&gt;首先，先完成能手动停止依赖的和触发。那么我就要有一个stop函数来完成关闭操作，之前通过run里面的函数渲染，使得属性触发了get操作。通过get函数里面编写的track函数，完成了依赖收集。然后通过trigger里面的依赖记录重新触发函数。在第5篇文章中，完成了依赖每次先清空再收集的函数，那么stop不就可以直接通过调用清空依赖，来达到停止触发的操作。同时把active设置为false，来关闭函数的更新。所以stop函数如下编写了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;class ReactiveEffect{
    ......
    constructor(public fn){
        ......
    }
    run(){
        ......
    }
    stop(){
        this.active =false;
        clearupEffect(this)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样的effect函数也要做相应的修改，抛出当前的runner对象，然后通过这个对象上的stop来操作停止命令。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export function effect(fn, options: any = {}) {
  // 这里的fn可以根据状态的变化，重新执行，effect可以嵌套着写
  const _effect = new ReactiveEffect(fn) //创建响应式的effect
  _effect.run() //默认先执行一次

  const runner = _effect.run.bind(_effect)// 绑定this执行
  runner.effect = _effect // 将_effect挂载到runner上 
  return runner
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样就可以在拿到effect到返回函数之后，通过&lt;code&gt;runner.effect.stop()&lt;/code&gt;来手动停止执行。&lt;/p&gt;
&lt;h2 id=&#34;schedule调度函数实现&#34;&gt;schedule调度函数实现&lt;/h2&gt;
&lt;p&gt;当用户在effect中的schedule中写了一个自己的一个操作，那么就能通过用户是否写了schedule函数来判断是否要执行用户的schedule，还是执行run()。&lt;br&gt;
了解了大致思路，我们先修改effect函数，增加一个对象，通过对象来传递用户编写的函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export function effect(fn, options: any = {}) {
  // 这里的fn可以根据状态的变化，重新执行，effect可以嵌套着写
  const _effect = new ReactiveEffect(fn, options.schedule) //创建响应式的effect
  _effect.run() //默认先执行一次

  const runner = _effect.run.bind(_effect) // 绑定this执行
  runner.effect = _effect // 将_effect挂载到runner上 
  return runner
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同时ReactiveEffect类上在构造函数上加入schedule参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;class ReactiveEffect{
    ......
    constructor(public fn, public schedule){
        ......
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下一步就是修改trigger函数，这样变量的属性改变的时候就知道是不是执行schedule函数了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export function trigger(target, type, key, value, oldValue) {
  const depsMap = targetMap.get(target)
  if (!depsMap) return //触发的值不在模版中
  let effects = depsMap.get(key)
  // 此处做逻辑修改，因为set在删除之后，再做添加，那么会造成死循环，有些方法会对数据拷贝之后再做修改
  // 可以避免这个问题
  if (effects) {
    effects = new Set(effects)
    effects.forEach((effect) =&amp;gt; {
      if (activeEffect !== effect) {
        if (effect.schedule) {
          effect.schedule() // 用户传入schedule的时候，就调用回调
        } else {
          effect.run() // 否则就刷新
        }
      }
      // 如果这里直接就写effect.run()，那么会遇到这种情况，在模版中赋值，那么也会触发这个，
      // 然后又通过了依赖收集的时候，运行它的第一次run（）。就会导致循环调用，爆栈，
      //所以这里需要加一个判断是否是当前的effect,如果是的话，就忽略这一次的赋值触发的run();
      //注意目前的代码是不支持异步的
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;到此为止，就能在测试html上调用自己写的schedule函数了，如开篇中的例子。&lt;br&gt;
&lt;a href=&#34;https://github.com/Stonewalling/vue3-plan/tree/effect_schedule&#34;&gt;源代码&lt;/a&gt;可供参考&lt;/p&gt;
">vue3源码学习-6-调度器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/G7P2Cs2zg/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;上篇回顾，核心代码逻辑是通过reactive中的Proxy()来代理一个对象，然后通过get收集依赖，主要操作放在来effect中。那么当我们回顾上一篇的问题。当用户有一个这样当操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;    const {effect,reactive} = VueReactivity;
    let target = {name:&amp;quot;david&amp;quot;,age:12,address:{num:567},flag:true}
    const state = reactive(target)
    effect(() =&amp;gt; {
        console.log(&amp;quot;render&amp;quot;)
        document.getElementById(&amp;quot;app&amp;quot;).innerHTML = state.flag ? &amp;quot;姓名:&amp;quot;+state.name : &amp;quot;年龄:&amp;quot;+state.age
        })
    setTimeout(() =&amp;gt; {
      state.flag = false
      setTimeout(() =&amp;gt; {
        console.log(&amp;quot;修改了name，原则不重新渲染&amp;quot;)
        state.name = &amp;quot;jack&amp;quot;
      },1000)
    },1000)
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;p&gt;第一次，执行来用户的渲染操作，然后在之后的操作中修改来flag。这个时候，依赖收集的应该是flag和name，如果采用上篇中的代码，那么实际上，旧的name依赖未被清除，还是会留在deps中，那么你修改name的时候会触发渲染。&lt;/p&gt;
&lt;h2 id=&#34;effect-分支删除&#34;&gt;effect 分支删除&lt;/h2&gt;
&lt;p&gt;上面的问题已经很清晰来，那么如果解决呢。可以在用户函数执行之前，把旧的依赖全部清空，再收集一次这个依赖不就行了。这样第一次收集了flag，name依赖。第二次flag变成flase,清空依赖，收集flag和age以来，这样第三次修改name值的时候就不会触发渲染了。&lt;br&gt;
前一篇中定义的deps也派上了用场，由于之前做了双向收集，那么在执行用户操作之前，清空依赖就行了。&lt;br&gt;
定义一个clearupEffect()函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;function clearupEffect(effect: ReactiveEffect) {
  let { deps } = effect
  for (let i = 0; i &amp;lt; deps.length; i++) {
    deps[i].delete(effect)
  }
  effect.deps.length = 0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;放入到 &lt;code&gt;this.fn()&lt;/code&gt;被执行之前，来清除依赖。但是这里会有个新问题，看代码。&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1654164372986.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这里执行了清空，下面执行了&lt;code&gt;this.fn()&lt;/code&gt;又会触发渲染，然后由于使用的是&lt;code&gt;Set()&lt;/code&gt;来存储关系的， &lt;code&gt;Set()&lt;/code&gt;一边清空一边添加依赖，导致了死循环，会一直触发渲染。为此依赖触发的方法要进行修改，我们拷贝一份&lt;code&gt;Set()&lt;/code&gt;，然后在他的基础上删除清空，这样就不会造成死循环了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;  // 此处做逻辑修改，因为set在删除之后，再做添加，那么会造成死循环，有些方法会对数据拷贝之后再做修改
  // 可以避免这个问题
  if (effects) {
    effects = new Set(effects)
    effects.forEach((effect) =&amp;gt; {
      if (activeEffect !== effect) effect.run() // 如果这里直接就写effect.run()，那么会遇到这种情况，在模版中赋值，那么也会触发这个，
      // 然后又通过了依赖收集的时候，运行它的第一次run（）。就会导致循环调用，爆栈，
      //所以这里需要加一个判断是否是当前的effect,如果是的话，就忽略这一次的赋值触发的run();
      //注意目前的代码是不支持异步的
    })
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;完整的effect代码&#34;&gt;完整的effect代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export let activeEffect = undefined

function clearupEffect(effect: ReactiveEffect) {
  let { deps } = effect
  for (let i = 0; i &amp;lt; deps.length; i++) {
    deps[i].delete(effect)
  }
  effect.deps.length = 0
}

class ReactiveEffect {
  // 这里代表在实例上新增active属性
  public active = true // 这个effect默认是激活状态
  public parent = null // 记录当前effect的父亲是谁，用作返回
  public deps = [] // 记录当前的effect都记录了哪些属性
  constructor(public fn) {} // 用户传递的参数也会绑定在this上 相当于this.fn = fn;
  run() {
    // run就是执行effect
    if (!this.active) {
      // 如果是非激活状态就是非激活状态，只需要执行函数，不需要进行依赖收集
      this.fn()
    }
    // 这里就要依赖收集了，核心就是当前的effect和稍后渲染的属性关联在一起
    try {
      this.parent = activeEffect
      activeEffect = this

      //在执行用户函数之前把依赖清空，再次收集
      clearupEffect(this)

      return this.fn() // 当稍后调用取只操作的时候就可以获取到这个全局的activeEffect了
    } finally {
      activeEffect = this.parent
    }
  }
}

export function effect(fn) {
  // 这里的fn可以根据状态的变化，重新执行，effect可以嵌套着写
  const _effect = new ReactiveEffect(fn) //创建响应式的effect
  _effect.run() //默认先执行一次
}

// 实例代码
// effect(() =&amp;gt; { age =&amp;gt;  e1
//   state.age;

//   effect(() =&amp;gt; { name =&amp;gt; e2
//     stage.name;
//   })

//   stage.name; name =&amp;gt; e1
// })
// 以前呢vue3.0的时候采用栈的方法将对象压栈,然后执行完成之后弹出这样就能关联
// 对应的effect
// 现在的做法是记录effect的父亲是谁，这样每次执行之后就把activeEffect 赋值为父亲对象
let targetMap = new WeakMap()
export function track(target, type, key) {
  // 在effect中的回调函数中，我们通过语句中执行的target属性收集到effect
  // 那么就有了target属性指到哪个effect，
  // 那么我们就明确了对象 某个属性-&amp;gt; 多个effect
  // 对象作为key,那么第一眼想到WeakMap,并且它还有个好处，当value为空的时候会被
  // 垃圾回收机制会回收它
  // 那么上述的数据结构应该是 {对象:Map{name:Set}}
  if (!activeEffect) return // 如果你不是在模版中触发了get，那么这个依赖就不要收集
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()))
  }
  let dep = depsMap.get(key)
  if (!dep) {
    depsMap.set(key, (dep = new Set()))
  }
  let shouldTrack = !dep.has(activeEffect) //一个属性多次依赖同一个effect那么去重
  if (shouldTrack) {
    dep.add(activeEffect)
    activeEffect.deps.push(dep) // 让deps记录住对应的dep，稍后在清理的地方用到
  }
  // 这里单向收集了这个依赖，对象的属性-&amp;gt;effect
  // 但是这样不方便。例如你有这么一个模版渲染
  // effect(() =&amp;gt; {flag ? state.age : state.name})
  // 那么在你flag判断为true和false的时候依赖的关联是不一样的
  // 所以我们也需要收集effect -&amp;gt; 属性
  // 在 ReactiveEffect上添加一个数组，来收集当前effect记录了哪些属性
}

export function trigger(target, type, key, value, oldValue) {
  const depsMap = targetMap.get(target)
  if (!depsMap) return //触发的值不在模版中
  let effects = depsMap.get(key)

  // 此处做逻辑修改，因为set在删除之后，再做添加，那么会造成死循环，有些方法会对数据拷贝之后再做修改
  // 可以避免这个问题
  if (effects) {
    effects = new Set(effects)
    effects.forEach((effect) =&amp;gt; {
      if (activeEffect !== effect) effect.run() // 如果这里直接就写effect.run()，那么会遇到这种情况，在模版中赋值，那么也会触发这个，
      // 然后又通过了依赖收集的时候，运行它的第一次run（）。就会导致循环调用，爆栈，
      //所以这里需要加一个判断是否是当前的effect,如果是的话，就忽略这一次的赋值触发的run();
      //注意目前的代码是不支持异步的
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Stonewalling/vue3-plan&#34;&gt;源代码地址&lt;/a&gt;&lt;/p&gt;
">vue3源码学习-5-分支切换</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/2lV26Y0JG/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;经过上文的响应式编写之后，实现了数据包裹之后变成了响应式数据，用户修改数据的时候能监听到操作。&lt;br&gt;
但是实际编写的响应式reactive.ts中最核心的是Proxy中的get和set方法。为此我们本次需要将核心代码抽离，并且编写effect副作用函数和依赖收集功能，这样函数依赖发生改变，他就重新执行。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;reativets核心代码抽离&#34;&gt;reative.ts核心代码抽离&lt;/h2&gt;
&lt;p&gt;响应式代码最重要的式get和set函数，那么对这一块逻辑抽离。并命名为baseHandles.ts,然后抛出。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// baseHandle.ts
export const enum ReactiveFlags {
  IS_RECEIVE = `__v_isReactive`,
}
export let baseHandles = {
  // 第一次是普通对象，只是代理，在取值的时候会调用get
  // 下一次你传入的是proxy的时候，可以看一下时候代理过，如果有，那么他一定走到了get方法，并且我们访问了ReactiveFlags.IS_RECEIVE，
  // 那么就表示这个是被代理过的，就直接返回 target
  get(target, key, recevier) {
    // return target[key]
    return Reflect.get(target, key, recevier)
  },
  set(target, key, value, recevier) {
    // target[key] = value
    return result
  },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在reactive.ts中把抽离的代码引入进去&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { isObject } from &#39;@vue/shared&#39;
import { baseHandles, ReactiveFlags } from &#39;./baseHandles&#39;
const reactiveMap = new WeakMap() // key只能是对象

// 将数据转化成响应式数据,只能做对象的代理
// 同一个对象呗代理多次返回同一个代理
// 代理再次被代理，返回原代理
export function reactive(target: object) {
  if (!isObject(target)) {
    return
  }
  //
  if (target[ReactiveFlags.IS_RECEIVE]) {
    return target
  }

  let existingProxy = reactiveMap.get(target)
  if (existingProxy) {
    return existingProxy
  }
  // 并没有重新定义属性，只是代理，在取值的时候会调用get，同理赋值调用set
  const proxy = new Proxy(target, baseHandles)
  reactiveMap.set(target, proxy)
  return proxy
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意这里出现的一个循环引用逻辑，但是这个不会再ES6中造成问题。reactive.ts中引入了baseHandles.ts,但是reactive.ts中对对象的代理包裹，我们应用了reactive.ts，并且包裹了数据，当数据改变的时候，就会触发set，而这个时候baseHandles.ts又依赖到了reactive.ts。造成了循环引用，但是这个不会导致任何的问题出现。&lt;/p&gt;
&lt;h2 id=&#34;effect功能的编写&#34;&gt;effect功能的编写&lt;/h2&gt;
&lt;p&gt;在测试官方代码的时候，是这么操作effect的。&lt;code&gt;effect(() =&amp;gt; {document.getElementById(&amp;quot;app&amp;quot;).innerHTML = state.name+&#39;今年&#39;+state.age})&lt;/code&gt;&lt;br&gt;
通过对上面的操作分析，可以知道通过effect运行了它里面的回调函数，也就是执行了渲染一个&lt;code&gt;谁今年多少岁&lt;/code&gt;的一段文字。当被effect包裹的回调函数中state.name和state.age参数改变的时候，我们还要更新下这一段文字。所以有了当前的effect对应这个stage上的nage和age的映射关系。&lt;br&gt;
再往深处思考，也会出现这种代码&lt;code&gt;effect(() =&amp;gt; {stage.name;effect(() =&amp;gt; {stage.age})})&lt;/code&gt;,这种嵌套的写法，这就是组件的写法了。&lt;br&gt;
上面的实例代码中外层effect1可以对应上stage.name，而里面的effect2对应上了stage.age。执行到当前的effect上的时候就能找到对应关联的属性。&lt;br&gt;
所以我们需要这么一个操作，对象的属性-&amp;gt;effect，而且如果一个属性可能在多个effect，那么对象作为key，最好的是自然就是WeakMap了，它还有个好处就是，当value为空的时候，垃圾回收机制对它进行回收。&lt;br&gt;
那么对上面对思路进行整合，得出我们需要一个这样对数据结构&lt;code&gt;{对象:Map{name:Set}}&lt;/code&gt;。那么现在来编写一下effect.ts，完成里面的依赖收集和属性改变的时候触发再次运行的函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;export let activeEffect = undefined //抛出当前运行的是哪个effect

class ReactiveEffect {
  // 这里代表在实例上新增active属性
  public active = true // 这个effect默认是激活状态
  public parent = null // 记录当前effect的父亲是谁，用作返回
  public deps = [] // 记录当前的effect都记录了哪些属性
  constructor(public fn) {} // 用户传递的参数也会绑定在this上 相当于this.fn = fn;
  run() {
    // run就是执行effect
    if (!this.active) {
      // 如果是非激活状态就是非激活状态，只需要执行函数，不需要进行依赖收集
      this.fn()
    }
    // 这里就要依赖收集了，核心就是当前的effect和稍后渲染的属性关联在一起
    try {
      this.parent = activeEffect
      activeEffect = this
      this.fn() // 当稍后调用取只操作的时候就可以获取到这个全局的activeEffect了
    } finally {
      activeEffect = this.parent
    }
  }
}
export function effect(fn) {
  // 这里的fn可以根据状态的变化，重新执行，effect可以嵌套着写
  const _effect = new ReactiveEffect(fn) //创建响应式的effect
  _effect.run() //默认先执行一次
}
// 实例代码
// effect(() =&amp;gt; { age =&amp;gt;  e1
//   state.age;

//   effect(() =&amp;gt; { name =&amp;gt; e2
//     stage.name;
//   })

//   stage.name; name =&amp;gt; e1
// })
// 以前呢vue3.0的时候采用栈的方法将对象压栈,然后执行完成之后弹出这样就能关联
// 对应的effect
// 现在的做法是记录effect的父亲是谁，这样每次执行之后就把activeEffect 赋值为父亲对象
let targetMap = new WeakMap()
//跟踪收集依赖
export function track(target, type, key) {
  // 在effect中的回调函数中，我们通过语句中执行的target属性收集到effect
  // 那么就有了target属性指到哪个effect，
  // 那么我们就明确了对象 某个属性-&amp;gt; 多个effect
  // 对象作为key,那么第一眼想到WeakMap,并且它还有个好处，当value为空的时候会被
  // 垃圾回收机制会回收它
  // 那么上述的数据结构应该是 {对象:Map{name:Set}}
  if (!activeEffect) return // 如果你不是在模版中触发了get，那么这个依赖就不要收集
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()))
  }
  let dep = depsMap.get(key)
  if (!dep) {
    depsMap.set(key, (dep = new Set()))
  }
  let shouldTrack = !dep.has(activeEffect) //一个属性多次依赖同一个effect那么去重
  if (shouldTrack) {
    dep.add(activeEffect)
    activeEffect.deps.push(dep) // 让deps记录住对应的dep，稍后在清理的地方用到
  }
  // 这里单向收集了这个依赖，对象的属性-&amp;gt;effect
  // 但是这样不方便。例如你有这么一个模版渲染
  // effect(() =&amp;gt; {flag ? state.age : state.name})
  // 那么在你flag判断为true和false的时候依赖的关联是不一样的
  // 所以我们也需要收集effect -&amp;gt; 属性
  // 在 ReactiveEffect上添加一个数组，来收集当前effect记录了哪些属性
}

//属性改变触发重新渲染
export function trigger(target, type, key, value, oldValue) {
  const depsMap = targetMap.get(target)
  if (!depsMap) return //触发的值不在模版中
  const effects = depsMap.get(key)
  effects &amp;amp;&amp;amp;
    effects.forEach((effect) =&amp;gt; {
      if (activeEffect !== effect) effect.run() // 如果这里直接就写effect.run()，那么会遇到这种情况，在模版中赋值，那么也会触发这个，
      // 然后又通过了依赖收集的时候，运行它的第一次run（）。就会导致循环调用，爆栈，
      //所以这里需要加一个判断是否是当前的effect,如果是的话，就忽略这一次的赋值触发的run();
      //注意目前的代码是不支持异步的
    })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的代码除了基础的分析之外，还有对3.0初期如何找到当前的effec的2种做法之外，还解决了模版渲染的时候又触发了run函数，导致循环调用的问题。&lt;br&gt;
那么上面的主要代码解释了收集依赖的过程，那么现在要对baseHandles.ts做一个依赖收集的入口。&lt;br&gt;
baseHandles.ts编写如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { isObject } from &#39;@vue/shared&#39;
import { baseHandles, ReactiveFlags } from &#39;./baseHandles&#39;
const reactiveMap = new WeakMap() // key只能是对象

// 将数据转化成响应式数据,只能做对象的代理
// 同一个对象呗代理多次返回同一个代理
// 代理再次被代理，返回原代理
export function reactive(target: object) {
  if (!isObject(target)) {
    return
  }
  //
  if (target[ReactiveFlags.IS_RECEIVE]) {
    return target
  }

  let existingProxy = reactiveMap.get(target)
  if (existingProxy) {
    return existingProxy
  }
  // 并没有重新定义属性，只是代理，在取值的时候会调用get，同理赋值调用set
  const proxy = new Proxy(target, baseHandles)
  reactiveMap.set(target, proxy)
  return proxy
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;结尾&#34;&gt;结尾&lt;/h2&gt;
&lt;p&gt;到目前为止，完成了所需要做的工作，这个时候可以在index.html上引入编写好的effect功能，先运行项目&lt;br&gt;
&lt;code&gt;npm run dev&lt;/code&gt;，然后倒入编译好的文件。从对象中获取编写的功能&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
  &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
  &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;!-- &amp;lt;script src=&amp;quot;./dist/reactivity.global.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;
  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;

  &amp;lt;!-- 官方的 --&amp;gt;
  &amp;lt;!-- &amp;lt;script src=&amp;quot;../../node_modules/@vue/reactivity/dist/reactivity.global.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;
  
  &amp;lt;!-- 自己实现的 --&amp;gt;
  &amp;lt;script src=&amp;quot;./dist/reactivity.global.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script&amp;gt;
    // effect 代表的是副作用函数，如果函数依赖发生改变，他就重新执行
    // reactive 将数据变成响应式 相当于proxy
    // shallowRactive,readonly,shallowReadonly
    const {effect,reactive} = VueReactivity;
    let target = {name:&amp;quot;david&amp;quot;,age:12,address:{num:567}}
    const state = reactive(target)
    const state2 = reactive(target)
    console.log(state === state2)
    //set 和 map 也可以劫持

    effect(() =&amp;gt; {
      state.age = Math.random(10);
      document.getElementById(&amp;quot;app&amp;quot;).innerHTML = `${state.name}今年${state.age}`
    })
    setTimeout(() =&amp;gt;{
      state.age = 13
    },1000)
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Stonewalling/vue3-plan&#34;&gt;源代码地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;未完待续&lt;/p&gt;
">vue3源码学习-4-effect编写以及依赖收集</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/Bgi0khNVA/"" data-c="
          &lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;
&lt;p&gt;在我们中学时代，学习过一元二次方程组的求解。由于对数学的理解不够深刻，只能简单利用高斯消元法，来求出一组2个2个未知数方程公式的解。例如下面一个公式:&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;{&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\begin{cases} 2x-y=0\\ -x+2y=3\\ \end{cases} 
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:3.0000299999999998em;vertical-align:-1.25003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size4&#34;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-l&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.69em;&#34;&gt;&lt;span style=&#34;top:-3.69em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.008em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.25em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.008em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.19em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;如何求解几何方程&#34;&gt;如何求解几何方程&lt;/h2&gt;
&lt;p&gt;对于上面的2个2个未知数方程式的解，他们代表了2条线交互于一点。就是他们的解(在有解的情况下，因为他们也许在x,y坐标上也可能不相交，就是2条相互平行的线)。这就是这组方程在几何上表达的关系，线性代数也能将他们描述成2个向量的和。实则他们都在解决同一个问题。转化为矩阵的情况如下:&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;[&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;[&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;[&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\begin{bmatrix} 2&amp;amp;-1\\ -1&amp;amp;2\\ \end{bmatrix} \begin{bmatrix} x\\ y\\ \end{bmatrix} = \begin{bmatrix} 0\\ 3\\ \end{bmatrix} 
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.40003em;vertical-align:-0.95003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;[&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;[&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.40003em;vertical-align:-0.95003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;[&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同时也可以看成&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A * x = b 
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;矩阵的乘法是左侧的行向量乘上右侧的列向量，就还原成列了上述的方程式。也可以从另一个角度变成:&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;[&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;[&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x \begin{bmatrix}2\\-1\\  \end{bmatrix} + y \begin{bmatrix} -1\\ 2\\\end{bmatrix}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.40003em;vertical-align:-0.95003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;[&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.40003em;vertical-align:-0.95003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;[&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么就理解成了找一个x倍数的列向量a和一个y倍数的列向量b，他们组合成列向量&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;[&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\begin{bmatrix} 0\\ 3\\ \end{bmatrix} 
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.40003em;vertical-align:-0.95003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;[&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么他们表达出来的图像就分别如下:&lt;br&gt;
行向量图&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1653704833211.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
列向量图&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1653704845670.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;方程的目的是什么&#34;&gt;方程的目的是什么&lt;/h2&gt;
&lt;p&gt;是寻找&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;[&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;[&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;x \begin{bmatrix}2\\-1\\  \end{bmatrix} + y \begin{bmatrix} -1\\ 2\\\end{bmatrix}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.40003em;vertical-align:-0.95003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;[&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.40003em;vertical-align:-0.95003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;[&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;的组合构成&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;[&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;mo fence=&#34;true&#34;&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\begin{bmatrix} 0\\ 3\\ \end{bmatrix} 
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.40003em;vertical-align:-0.95003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;[&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这2张图都是针对同一个问题提出的2种看法，他们的解是一样的。&lt;/p&gt;
&lt;h2 id=&#34;选取所有的xy组合起来是什么&#34;&gt;选取所有的x,y组合起来，是什么&lt;/h2&gt;
&lt;p&gt;如果2个向量不能相互表示，那么他们就能通过改变x,y的系数来得到这个平面上的所有向量，就好像x轴和y轴一样。同理对于一个3*3的方程组，例如:&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;{&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\begin{cases} 2x-y+0z=0\\ -x+2y-z=-1\\ 0x-3y+4z=4\\ \end{cases} 
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:4.32em;vertical-align:-1.9099999999999997em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;&lt;span class=&#34;delimsizing mult&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.35002em;&#34;&gt;&lt;span style=&#34;top:-2.19999em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎩&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.19999em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎪&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1500100000000004em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎨&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.30001em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎪&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-4.60002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;delimsizinginner delim-size4&#34;&gt;&lt;span&gt;⎧&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.8500199999999998em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-l&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:2.41em;&#34;&gt;&lt;span style=&#34;top:-4.41em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.008em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.97em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.008em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-1.5300000000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.008em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.9099999999999997em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于上面三个方程组，我们假设一下去取出他的值(就是固定一个列向量，另外2个列向量的系数随机构成只要结果和右侧相等)，那么每一个方程就得到了一个平面，3个平面相交于一点就是他们的解。&lt;br&gt;
那么对于他们的列向量图像:&lt;br&gt;
&lt;img src=&#34;https://micromatrix.cf/post-images/1653705454508.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;保持a不变那么对于任意的b是否可以求出解所有的列的线性组合是否可以覆盖三维空间上面的方程组是3个未知数的&#34;&gt;保持A不变，那么对于任意的b是否可以求出解(所有的列的线性组合是否可以覆盖三维空间，上面的方程组是3个未知数的)&lt;/h2&gt;
&lt;p&gt;上述方程可以，因为他们的列是独立的，无法相互表达，这叫做非奇异矩阵或可逆矩阵，也可以说他们不能同时在一个平面上，如果他们在同一个平面上那么他们之间的组合也一定在在这个平面上，虽然有3列，但是其中实际只有2列，因为其他的2列能组合成第三列&lt;/p&gt;
">线性代数学习笔记-1-方程组的几何解释</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/YAIFCls7o/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;在实际开发中，部署的项目在服务器上，通过域名来访问，是否会发现有的域名是http协议有的是https协议。那么同一个网站，他既可以http访问，又可以https访问，他们是什么呢，他们之间有什么区别呢？&lt;/p&gt;
&lt;h2 id=&#34;简单介绍下http和https&#34;&gt;简单介绍下http和https&lt;/h2&gt;
&lt;p&gt;http中文名称是超文本网络传输协议，深究一下呢，他是一种分布式、协作式和超媒体信息系统的应用层协议，简单的说就是接受和发送HTML页面的方法，用来在Web和服务器之间传递信息。&lt;br&gt;
https是基于SSL+HTTP组合而来的，中文名称就是超文本网络传输安全协议，由Http通信然后再把信息通过SSL/TLS加密。这样的话就能让数据很安全，不会被第三方获取你发了什么信息。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;http和https的区别&#34;&gt;Http和Https的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;http默认端口是80，https的默认端口是443&lt;/li&gt;
&lt;li&gt;http不需要CA证书，https需要CA证书&lt;/li&gt;
&lt;li&gt;http需要TCP握手3次，https的话再Http的3次握手基础上，还需要SSL/TLS的加密握手9次，总计12次&lt;/li&gt;
&lt;li&gt;从连接的方式上看就知道http是明文发送，而https是需要加密发送的信息的&lt;/li&gt;
&lt;li&gt;从第三也可知道，http的速度比https的速度快，占用服务器资源少&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;http是怎么进行连接的&#34;&gt;Http是怎么进行连接的？&lt;/h2&gt;
&lt;p&gt;首先，浏览器根据url获取域名对应的IP，如果没有会去DNS查找。当拿到服务器IP之后，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次握手会给服务器发送一个随机值(准确的名称是同步序列值)SYN包(也可以说是SYN=1,seq=x,ACK=0)，设置发送需要为X给服务器。进入SYN_SEND状态，等待服务器回应。&lt;/li&gt;
&lt;li&gt;第二次握手是服务器拿到之后会确认ACK=X+1,并且也发送个SYN的包，这个包就是(SYN=1,Seq=y,ACK=x+1)给客户端,服务器进入SYN_RECV状态。&lt;/li&gt;
&lt;li&gt;第三次握手客户端拿到了服务器给的SYN包，也就是同步序列包，然后发送确认包ACK(ack=y+1)，大致包的样子就是(Seq=x+1，Ack=y+1)。发送给服务器之后，服务器确认，然后就进入了ESTABLISHED状态，，完成了3次握手&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;那么https是怎么工作的呢&#34;&gt;那么Https是怎么工作的呢？&lt;/h2&gt;
&lt;p&gt;Https通过上面的Http的3次握手，之后就进入了SSL/TLS的加密握手。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送Url连接了一下服务器。&lt;/li&gt;
&lt;li&gt;服务器会生成公钥和私钥(公钥和私钥，分别就像一把锁和一把能打开这个锁的钥匙)。&lt;/li&gt;
&lt;li&gt;就会把自己的公钥发送给客户端。&lt;/li&gt;
&lt;li&gt;，客户端拿到了公钥(也就是之前提到的CA证书)，如果没通过就会提示这个网站危险的页面，那么在通过验证的时候会生成一个随机值，那么这个随机值就是客户端的私钥了。&lt;/li&gt;
&lt;li&gt;就会用服务器给的私钥加密随机值发送给服务器。&lt;/li&gt;
&lt;li&gt;服务器拿到了加密数据通过自己的私钥解锁出客户端的随机key，那么用该key来加密要发送的内容。&lt;/li&gt;
&lt;li&gt;发送加密的内容给客户端&lt;/li&gt;
&lt;li&gt;客户端拿到了加密内容，用key解密出来。&lt;/li&gt;
&lt;/ol&gt;
">Http和Https学习(一)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/2g6zqGwDC/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;前端开发过程中，总会遇到点击链接下载。这个时候可以借助2种方法解决。一种是用a标签的download，第二种是按钮点击之后调用接口来下载。2种方法最好确定文件没有跨域现象。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;a标签download&#34;&gt;a标签download&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;//点击按钮或者什么，生成a链接，然后将文件地址放在上面
downloadFile(url, fileName) {
    const _this = this;
    let aLink = document.createElement(&amp;quot;a&amp;quot;);
    document.body.appendChild(aLink);
    aLink.setAttribute(&amp;quot;href&amp;quot;, url);
    aLink.setAttribute(&amp;quot;download&amp;quot;, fileName);
    aLink.click();
    // document.body.removeChild(aLink);
},
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ajax或者fetch访问下载&#34;&gt;ajax或者fetch访问下载&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;/**
* @description:
* @param {*} url 目标文件地址
* @param {*} filename 目标文件名
* @return {*}
* @Date: 2021-02-26 10:05:51
* @Author: David
*/
downloadFile(url, filename) {
const _this = this;
_this.getBlob(url, function(blob) {
_this.saveAs(blob, filename);
});
},
getBlob(url, cb) {
	var xhr = new XMLHttpRequest();
	xhr.open(&amp;quot;GET&amp;quot;, url, true);
	xhr.responseType = &amp;quot;blob&amp;quot;;
	xhr.onload = function() {
	if (xhr.status === 200) {
		cb(xhr.response);
	}
};
xhr.send();
},
/**
* @description: 保存
* @param {*} blob
* @param {*} filename 想要保存的文件名称
* @return {*}
* @Date: 2021-02-26 10:05:32
* @Author: David
*/
saveAs(blob, filename) {
	if (window.navigator.msSaveOrOpenBlob) {
		navigator.msSaveBlob(blob, filename);
	} else {
		var link = document.createElement(&amp;quot;a&amp;quot;);
		var body = document.querySelector(&amp;quot;body&amp;quot;);
		link.href = window.URL.createObjectURL(blob);
		link.download = filename;
		// fix Firefox
		link.style.display = &amp;quot;none&amp;quot;;
		body.appendChild(link);
		link.click();
		body.removeChild(link);
		window.URL.revokeObjectURL(link.href);
	}
},
&lt;/code&gt;&lt;/pre&gt;
">前端实现文件下载</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/wpl5zRerH/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;经过前面的环境搭建以及项目构建，完成了基础的项目框架，下面学习实现vue3的reactivity。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;观察官方如何使用&#34;&gt;观察官方如何使用&lt;/h2&gt;
&lt;p&gt;首先修改.npmrc文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 解决一个问题 例如vue中有个依赖abc ，那么我们安装了vue就可以直接用abd，有一天vue不依赖abc了，那么你用abc就出错了，未来让这种幽灵依赖以后不出错，就在这里配置羞耻提升
shamefully-hoist = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在vue3-plan上安装vue3&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pnpm install vue -w
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候发现node_moules中vue的依赖被展开了放在根目录上，在packages/reactivity/index.html上引入vue官方的reactivity。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
  &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
  &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;!-- &amp;lt;script src=&amp;quot;./dist/reactivity.global.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;
  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;

  &amp;lt;!-- 官方的 --&amp;gt;
  &amp;lt;script src=&amp;quot;../../node_modules/@vue/reactivity/dist/reactivity.global.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  
  &amp;lt;!-- 自己实现的 --&amp;gt;
  &amp;lt;!-- &amp;lt;script src=&amp;quot;./dist/reactivity.global.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;
  &amp;lt;script&amp;gt;
    // effect 代表的是副作用函数，如果函数依赖发生改变，他就重新执行
    // reactive 将数据变成响应式 相当于proxy
    // shallowRactive,readonly,shallowReadonly
    const {effect,reactive} = VueReactivity;

    const state = reactive({name:&amp;quot;david&amp;quot;,age:12,address:{num:567}})

    //set 和 map 也可以劫持

    effect(() =&amp;gt; {
      document.getElementById(&amp;quot;app&amp;quot;).innerHTML = `${state.name}今年${state.age}`
    })
    setTimeout(() =&amp;gt;{
      state.age = 13
    },1000)
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过上面的实验观察发现通过reactive包裹之后的对象，能被监听到变化，然后effect通过监听到变化而触发回调函数，从而打印出上面到语句。并且reactive是能深层检测到对象的改变，当你修改了address里面的num值时也能被监听到变化，这得益于vue3采用到proxy。shallowRactive和shallowReadonly如名字，只能监听到表层，以为深处到属性并未做包装。&lt;/p&gt;
&lt;h3 id=&#34;vue3对比vue2的变化&#34;&gt;vue3对比vue2的变化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在Vue2的时候采用&lt;code&gt;defineProperty&lt;/code&gt;来进行数据的劫持，需要对属性进行重写&lt;code&gt;getter&lt;/code&gt;和&lt;code&gt;setter&lt;/code&gt;性能差。&lt;/li&gt;
&lt;li&gt;当新增属性和删除属性式就无法监听变化，需要通过&lt;code&gt;$set&lt;/code&gt;、&lt;code&gt;$delete&lt;/code&gt;实现。&lt;/li&gt;
&lt;li&gt;数组不采用defineProperty来进行劫持(浪费性能，对所有索引进行劫持会造成性能的浪费)需要对数组单独进行处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Vue3使用Proxy来实现响应式数据变化，从而解决上述问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;编写自己的响应式&#34;&gt;编写自己的响应式&lt;/h2&gt;
&lt;p&gt;首先引入的JS文件的html，从官方的引入链接改成引入自己的链接&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
  &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
  &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;!-- &amp;lt;script src=&amp;quot;./dist/reactivity.global.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;
  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;

  &amp;lt;!-- 官方的 --&amp;gt;
  &amp;lt;!-- &amp;lt;script src=&amp;quot;../../node_modules/@vue/reactivity/dist/reactivity.global.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; --&amp;gt;
  
  &amp;lt;!-- 自己实现的 --&amp;gt;
  &amp;lt;script src=&amp;quot;./dist/reactivity.global.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script&amp;gt;
    // effect 代表的是副作用函数，如果函数依赖发生改变，他就重新执行
    // reactive 将数据变成响应式 相当于proxy
    // shallowRactive,readonly,shallowReadonly
    const {effect,reactive} = VueReactivity;

    const state = reactive({name:&amp;quot;david&amp;quot;,age:12,address:{num:567}})

    //set 和 map 也可以劫持

    effect(() =&amp;gt; {
      document.getElementById(&amp;quot;app&amp;quot;).innerHTML = `${state.name}今年${state.age}`
    })
    setTimeout(() =&amp;gt;{
      state.age = 13
    },1000)
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;为功能划分文件&#34;&gt;为功能划分文件&lt;/h3&gt;
&lt;p&gt;在reactivity/src/下新建&lt;mark&gt;effect.ts&lt;/mark&gt;和&lt;mark&gt;reactive.ts&lt;/mark&gt;文件，对应上面html的2个功能。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;# reactive.ts
export function reactive() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;# effect.ts
export function effect() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同时在index.ts中抛出这2个函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { effect } from &#39;./effect&#39;
import { reactive } from &#39;./reactive&#39;

export { effect, reactive }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样html中引入编译好的JS文件就能获取这2个函数了。&lt;/p&gt;
&lt;h4 id=&#34;编写reactive功能&#34;&gt;编写reactive功能&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { isObject } from &#39;@vue/shared&#39;

// 将数据转化成响应式数据,只能做对象的代理
export function reactive(target: object) {
  if (!isObject(target)) {
    return
  }

  // 并没有重新定义属性，只是代理，在取值的时候会调用get，同理赋值调用set
  const proxy = new Proxy(target, {
    get(target, key, recevier) {
      return target[key]
    },
    set(target, value, key, recevier) {
      target[key] = value
      return true
    },
  })
  return proxy
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面定义个了proxy代理对象，但是为啥不能如上图编写。看下面的解析&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;# 代码省略，和上面的一致
let target = {
    name : &amp;quot;java&amp;quot;,
    get alias(){ //属性访问器写法 es5
        console.log(this); // this  { name: &#39;java&#39;, alias: [Getter] }
        return this.name;
    }
}
const proxy = new Proxy(target, {
    get(target, key, recevier) {
    //   return target[key] ;

    // 这里控制台会打印出 alias  name
        console.log(key)
        return Reflect.get(target,key,recevier)
    },
    set(target, value, key, recevier) {
      target[key] = value
      return true
    },
  })
  proxy.alias
//   通过proxy.alias，触发了get，然后return target[key]，这个时候访问的是原对象target，traget又访问alias，alias访问了name,但是这个this是源对象，监控不到name，所以引入Reflect(反射)对象，这样访问alias,就回去代理对象上取值，这个时候this就变成了代理对象，那么this.name就又走一次get，这样name就被监控到。 recevier的作用是改变this指向
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过上面的修改，初步得到了一个代理对象的方法。此时如果用户在使用上面的代码的时候，他是这么写的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt; const {effect,reactive} = VueReactivity;
 let target = {name:&amp;quot;david&amp;quot;,age:13,address:{num:134}};
 let p1 = reactive(target)
 let p2 = reactive(target)
console.log(p1 === p2) //打印出false，因为每次都new了一个新的Porxy();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么实际上这2个应该使用一个对象的，为此我们修改一下上面的代码，增加缓存设置，这里用上了&lt;code&gt;WeakMap&lt;/code&gt;。弱链接Map，好处在于key为null自动清空对应映射关系，其二是key只能为对象。修改上面的代码为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { isObject } from &#39;@vue/shared&#39;

// 将数据转化成响应式数据,只能做对象的代理
export function reactive(target: object) {
import { isObject } from &#39;@vue/shared&#39;
const reactiveMap = new WeakMap() // key只能是对象
// 将数据转化成响应式数据,只能做对象的代理
export function reactive(target: object) {
  if (!isObject(target)) {
    return
  }

  let existingProxy = reactiveMap.get(target)
  if (existingProxy) {
    return existingProxy
  }
  // 并没有重新定义属性，只是代理，在取值的时候会调用get，同理赋值调用set
  const proxy = new Proxy(target, {
    get(target, key, recevier) {
      // return target[key]
      console.log(key)
      return Reflect.get(target, key, recevier)
    },
    set(target, value, key, recevier) {
      // target[key] = value
      // return true
      return Reflect.set(target, key, value, recevier)
    },
  })
  reactiveMap.set(target, proxy)
  return proxy
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候reactive就有了同一个对象代理多次，返回同一个代理。现在又有个新需求，如果代理再一次被代理，那应该返回代理，而不是代理的代理对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;    let target = {name:&amp;quot;david&amp;quot;,age:12,address:{num:567}}
    const state = reactive(target)
    const state2 = reactive(state)
    console.log(state === state2) //false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么怎么让判断为true呢，早期的处理方式是，WeakMap，正方向存一次，反方向存一次就像&lt;br&gt;
target -&amp;gt; proxy&lt;br&gt;
proxy -&amp;gt; target&lt;br&gt;
最新的处理方法是定一个枚举变量。当你你传入的是proxy的时候，可以看一下时候代理过，如果有，那么他一定走到了get方法，并且我们访问了ReactiveFlags.IS_RECEIVE，那么就表示这个是被代理过的，就直接返回 target。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import { isObject } from &#39;@vue/shared&#39;
const reactiveMap = new WeakMap() // key只能是对象
const enum ReactiveFlags {
  IS_RECEIVE = `__v_isReactive`,
}
// 将数据转化成响应式数据,只能做对象的代理
// 同一个对象被代理多次返回同一个代理
// 代理再次被代理，返回原代理
export function reactive(target: object) {
  if (!isObject(target)) {
    return
  }
  //
  if (target[ReactiveFlags.IS_RECEIVE]) {
    return target
  }

  let existingProxy = reactiveMap.get(target)
  if (existingProxy) {
    return existingProxy
  }
  // 并没有重新定义属性，只是代理，在取值的时候会调用get，同理赋值调用set
  const proxy = new Proxy(target, {
    // 第一次是普通对象，只是代理，在取值的时候会调用get
    // 下一次你传入的是proxy的时候，可以看一下时候代理过，如果有，那么他一定走到了get方法，并且我们访问了ReactiveFlags.IS_RECEIVE，
    // 那么就表示这个是被代理过的，就直接返回 target
    get(target, key, recevier) {
      // return target[key]
      if (key == ReactiveFlags.IS_RECEIVE) {
        return true
      }
      console.log(key)
      return Reflect.get(target, key, recevier)
    },
    set(target, value, key, recevier) {
      // target[key] = value
      // return true
      return Reflect.set(target, key, value, recevier)
    },
  })
  reactiveMap.set(target, proxy)
  return proxy
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Stonewalling/vue3-plan&#34;&gt;源代码地址&lt;/a&gt;&lt;/p&gt;
">vue3源码学习-3-实现reactivity</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/TMTlJU-Su/"" data-c="
          &lt;h2 id=&#34;踩坑记录-uncaught-typeerror-object-is-not-a-function&#34;&gt;踩坑记录 Uncaught TypeError: Object(...) is not a function&lt;/h2&gt;
&lt;p&gt;原本旧项目框架的问题，导致打包的内容比较大，vendor这种文件达到了4M，个人感觉是存在一些问题的，想着优化下，正巧同事做了新模版，打包之后整体文件也就在2M左右，太强了，看来vue-cli脚手架还是要研究研究。&lt;br&gt;
但是，当我满怀希望的替换了模版之后发现，启动报错&lt;mark&gt;Uncaught TypeError: Object(...) is not a function&lt;/mark&gt;，这个BUG是在我修改完其他的文件缺，再我移入旧项目的vuex中出现的。我第一感觉就是vuex哪里有啥问题。&lt;s&gt;在此吐槽先C开头的某知名程序网站，乱指引，我排查了3个多小时的上面提到的大小写，命名，以及导出错误，结果在知乎上看到一个和我一样经历的文章&lt;/s&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;这个时候我才知道是版本的不一致导致的，我的vue版本是2.x，而新的模版的vuex版本在4.x，导致不兼容匹配。这里可以去查看package.json文件。&lt;br&gt;
于是解决方案就出来了，升级vue版本到3.x或者降低vuex到3.x：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;cnpm uninstall vuex
cnpm install vuex@3.0.1 --save
&lt;/code&gt;&lt;/pre&gt;
">Vue项目中配置vuex版本问题错误</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/02UZJGsyD/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;服务器本身很垃圾，是一个小鸡服务器，Java后端程序经常崩溃，所以用sh脚本简单的做一个自动重启命令&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;脚本&#34;&gt;脚本&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/sh
#切换到目录
cd /usr/local/app
date=`date`
#查询端口占用
lsof -i:8080
# $? -ne 0 不存在 $? -eq 0存在
if [ $? -ne 0 ]
then nohup java -jar xxx.jar &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp; echo $date &amp;quot;:=============== restart ===============&amp;quot; &amp;gt;&amp;gt; monitoring.log
else echo $date &amp;quot;:=============== is normal ==============&amp;quot; &amp;gt;&amp;gt; monitoring.log
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;添加计时脚本&#34;&gt;添加计时脚本&lt;/h2&gt;
&lt;p&gt;Linux crontab 命令&lt;br&gt;
Linux crontab是用来定期执行程序的命令。&lt;br&gt;
当安装完成操作系统之后，默认便会启动此任务调度命令。&lt;br&gt;
&lt;strong&gt;添加或更新crontab命令&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;crontab -e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;追加一条命令&lt;/strong&gt;&lt;br&gt;
每分钟执行脚本文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;* * * * * . /etc/profile;/bin/sh /usr/local/app/monitoring.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;重启crond&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;service crond restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;查看当前系统登录用户的Crontab命令集合&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;crontab -l
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;br&gt;
如果我们使用 crontab 来定时执行脚本，无法执行，但是如果直接通过命令（如：./test.sh)又可以正常执行，这主要是因为无法读取环境变量的原因。&lt;br&gt;
解决：在 crontab 中添加环境变量，在可执行命令之前添加命令 . /etc/profile;/bin/sh，使得环境变量生效&lt;/p&gt;
">Linux 简单弄一个自动启动脚本</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/aEL11eK0A/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;docker技术虽然发展了很多年，而且k8s表示不再支持它，但是这个容器技术目前拿来玩一玩还是不错的，装docker-compose则能一次控制多台容器。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ol&gt;
&lt;li&gt;安装docker&lt;br&gt;
商店安装或者使用下面的命令安装&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;curl -sSL https://get.docker.com/ | sh
systemctl enable --now docker
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;安装docker-compose&lt;br&gt;
由于宝塔商店中没有这个插件,所以手动安装v2.1.1版本&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;curl -L https://github.com/docker/compose/releases/download/v2.1.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;安装完后检查版本&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;docker-compose -v
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;卸载docker-compose&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;sudo rm /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;
">Linux 宝塔面板安装docker-compose</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/Vg8wTNwfK/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近服务器项目部署需要不同版本的Java，在Mac上领略了jenv的简单，易管理的优点，，所以便打算在Linux上也安装这个。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;安装jenv&#34;&gt;安装jenv&lt;/h2&gt;
&lt;p&gt;Jenv配置方法很简单，两个方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一种是使用Git自动部署&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;git clone https://github.com/jenv/jenv.git ~/.jenv
echo &#39;export PATH=&amp;quot;$HOME/.jenv/bin:$PATH&amp;quot;&#39; &amp;gt;&amp;gt; ~/.bash_profile
echo &#39;eval “$(jenv init -)”&#39; &amp;gt;&amp;gt; ~/.bash_profile
source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;等待片刻后，部署配置完成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种是手动部署，因为我的服务器无法连接github,先去&lt;a href=&#34;https://github.com/jenv/jenv/releases&#34;&gt;Github&lt;/a&gt;连接下载这个文件，通过某些方式传送到你的服务器上。然后把它解压到/etc/jenv位置，这个随个人习惯，主要是后面的配置文件内容统一就好。编辑/etc/profile.在文件末尾加入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;export PATH=&amp;quot;/etc/jenv/bin:$PATH&amp;quot;
eval &amp;quot;$(jenv init -)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;加入完成后&lt;/p&gt;
&lt;p&gt;source /etc/profile&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你是zsh使用者，那么把上述的环境变量配置设置到.zshrc中&lt;br&gt;
最后没有输出任何错误，就可以jenv查看是否安装成功&lt;/p&gt;
&lt;h2 id=&#34;如何使用&#34;&gt;如何使用&lt;/h2&gt;
&lt;p&gt;Jenv的使用很简单，利用配置JDK8的方法，我下载了JDK11，存储地址是/usr/local/java/java_1.8，我们添加到Jenv里&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;jenv add /usr/local/java/java_1.8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，jenv自动检录多余的名称。你可以放任不管，但是如果你是“强迫症”人群，可以手动&lt;u&gt;remove&lt;/u&gt;多余名称&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;jenv remove 名字
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后，使用versions命令，可以看到Jenv管理的JDK版本：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;jenv versions
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们要在当前目录下，调用JDK11时候，终端输入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;jenv local 版本号
&lt;/code&gt;&lt;/pre&gt;
">Linux 安装Jenv Java管理工具</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/n75oVPLZa/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近配了一台服务器,配置清单cpu: e2660、内存: 16*2 ecc。&lt;br&gt;
使用 proxmox 安装了多台虚拟机,使用其中的 3 台 4c 8g 的搭建了一个 3 节点的 k8s 集群。因为没有公网 ip或者说进不了电信光猫改不了配置,不能直接通过公网访问到内网，所以使用 frp 内网穿透，提供公网访问。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;预期实现的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可通过域名直接访问内网，不带端口，eg: http://ltinyho.top&lt;/li&gt;
&lt;li&gt;支持 https, eg: https://ltinyho.top&lt;/li&gt;
&lt;li&gt;支持 websocket&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内网穿透配置&#34;&gt;内网穿透配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将域名绑定到具有公网ip的服务器&lt;/li&gt;
&lt;li&gt;将80和443端口的流量转发到 fprs http监听的 7080端口。这样流量就会通过 frps -&amp;gt; frpc 到内网宿主机。&lt;/li&gt;
&lt;li&gt;将配置的域名的流量都转到本地的 80 端口。&lt;/li&gt;
&lt;li&gt;反向代理，将流量代理到 k8s 集群&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;map $http_upgrade $connection_upgrade {
  default upgrade;
  &#39;&#39;      close;
}
server {
    listen 80;
    server_name *.ltinyho.top ltinyho.top;
    listen 443 ssl; # managed by Certbot
    ssl_certificate /etc/letsencrypt/live/ltinyho.top/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/ltinyho.top/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot
    location / {
        proxy_pass http://localhost:7080;
        proxy_set_header Host      $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade; #配置weboscket
        proxy_set_header Connection $connection_upgrade;#配置weboscket
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fprs 配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;bind_addr = 0.0.0.0
bind_port = 7000
bind_udp_port = 7001
kcp_bind_port = 7000
vhost_http_port = 7080
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内网宿主机nginx配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  server 192.168.199.111:80;
  server 192.168.199.112:80;
  server 192.168.199.113:80;
}
map $http_upgrade $connection_upgrade {
  default upgrade;
  &#39;&#39;      close;
}
server {
    listen       80;
    server_name  *.ltinyho.top ltinyho.top;
    location / {
      proxy_pass http://k8s;
      proxy_set_header Host      $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection $connection_upgrade;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内网 frpc 配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[common]
server_addr = 47.98.137.255
server_port = 7000
[lt-http]
type = http
local_ip = 127.0.0.1
local_port = 80
custom_domains = *.ltinyho.top,ltinyho.top
remote_port = 7080
&lt;/code&gt;&lt;/pre&gt;
">Proxmox 搭建K8服务</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/VL2F9qU_1/"" data-c="
          &lt;h1 id=&#34;下载烧录镜像&#34;&gt;下载烧录镜像&lt;/h1&gt;
&lt;p&gt;我这里采用的是下载https://www.proxmox.com/en/downloads，然后通过UltraISO安装，工具-&amp;gt;制作硬盘映像,raw格式，烧录完成后，和你平常做系统一样，进入快捷启动菜单，找到你的U盘并启动它。(或者去BIOS设置你的U盘为第一启动选项)&lt;/p&gt;
&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;
&lt;p&gt;图形化安装页面，进入后安装提示安装，注意的地方是在IP那里，填写一个你路由器没有被占用的IP，后面要通过它进入网页。&lt;/p&gt;
&lt;h1 id=&#34;坑&#34;&gt;坑&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;网络&lt;br&gt;
它的工作模式是通过物理网卡走桥接模式到他自己的虚拟网卡上。第一次进入后插入网线发现无法上网，通过命令&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#重启网卡
systemctl restart networking
#检查网络
ping www.baidu.com
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;vi&lt;br&gt;
这是网上资料显示是debian上vi有BUG，表现为无法使用方向键和insert模式等。我们可以通过安装vim来解决问题。&lt;/li&gt;
&lt;li&gt;源&lt;br&gt;
它自己带的管理包源有IPv6和慢等原因，无法升级和安装vim，所以我更新了它的源&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#删除企业源
rm -rf /etc/apt/sources.list.d/pve-enterprise.list
#添加非订阅源
echo &amp;quot;deb https://mirrors.ustc.edu.cn/proxmox/debian/pve/ buster pve-no-subscription &amp;quot; &amp;gt;/etc/apt/sources.list.d/pve-install-repo.list
#添加ceph源
echo &amp;quot;deb https://mirrors.ustc.edu.cn/proxmox/debian/ceph-nautilus buster main &amp;quot; &amp;gt;/etc/apt/sources.list.d/pve-ceph.list
# 建议同时使用国内debian源
vim /etc/apt/sources.list
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free
&lt;/code&gt;&lt;/pre&gt;
">笔记本安装proxmox</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/pBjD9UZfg/"" data-c="
          &lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;
&lt;p&gt;因PVE7.0更换了Debian11作为内核，软件源管理方式也发生了变更，故原软件源配置方法已失效。&lt;/p&gt;
&lt;p&gt;默认是企业订阅版，如果不做修改，在使用 pveceph init 进行 ceph 初始化安装的时候会将整个环境破坏，切记！&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;strong&gt;登陆各节点Shell控制台&lt;/strong&gt;&lt;br&gt;
**【重要】**将/etc/apt/sources.list.d/pve-enterprise.list 文件内的唯一一条记录注释掉：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;echo&amp;quot;#deb https://enterprise.proxmox.com/debian/pve bullseye pve-enterprise&amp;quot; &amp;gt; /etc/apt/sources.list.d/pve-enterprise.list
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;proxmox软件源更换&#34;&gt;Proxmox软件源更换&lt;/h2&gt;
&lt;p&gt;中科大源（二选一）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;wget https://mirrors.ustc.edu.cn/proxmox/debian/proxmox-release-bullseye.gpg -O /etc/apt/trusted.gpg.d/proxmox-release-bullseye.gpg
echo &amp;quot;deb https://mirrors.ustc.edu.cn/proxmox/debian/pve bullseye pve-no-subscription&amp;quot; &amp;gt; /etc/apt/sources.list.d/pve-no-subscription.list     #中科大源
echo &amp;quot;deb https://mirrors.ustc.edu.cn/proxmox/debian/ceph-pacific bullseye main&amp;quot; &amp;gt; /etc/apt/sources.list.d/ceph.list     #中科大源
sed -i.bak &amp;quot;s#http://download.proxmox.com/debian#https://mirrors.ustc.edu.cn/proxmox/debian#g&amp;quot; /usr/share/perl5/PVE/CLI/pveceph.pm     #中科大源
apt update &amp;amp;&amp;amp; apt dist-upgrade     #更新软件，可不执行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Proxmox中文社区源（二选一）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;wget http://download.proxmox.wiki/debian/proxmox-release-bullseye.gpg -O /etc/apt/trusted.gpg.d/proxmox-release-bullseye.gpg
echo &amp;quot;deb http://download.proxmox.wiki/debian/pve bullseye pve-no-subscription&amp;quot; &amp;gt; /etc/apt/sources.list.d/pve-no-subscription.list     #Proxmox中文社区源
echo &amp;quot;deb https://download.proxmox.wiki/debian/ceph-pacific bullseye main&amp;quot; &amp;gt; /etc/apt/sources.list.d/ceph.list     #Proxmox中文社区源
sed -i.bak &amp;quot;s#http://download.proxmox.com/debian#https://download.proxmox.wiki/debian#g&amp;quot; /usr/share/perl5/PVE/CLI/pveceph.pm     #Proxmox中文社区源
apt update &amp;amp;&amp;amp; apt dist-upgrade     #更新软件，可不执行
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;debian系统源更换&#34;&gt;Debian系统源更换&lt;/h2&gt;
&lt;p&gt;阿里Debian源（二选一）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;sed -i.bak &amp;quot;s#ftp.debian.org/debian#mirrors.aliyun.com/debian#g&amp;quot; /etc/apt/sources.list     #阿里Debian源
sed -i &amp;quot;s#security.debian.org#mirrors.aliyun.com/debian-security#g&amp;quot; /etc/apt/sources.list     #阿里Debian源
apt update &amp;amp;&amp;amp; apt dist-upgrade     #更新软件，可不执行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;163-Debian源（二选一）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;sed -i.bak &amp;quot;s#ftp.debian.org/debian#mirrors.163.com/debian#g&amp;quot; /etc/apt/sources.list     #163Debian源
sed -i &amp;quot;s#security.debian.org#mirrors.163.com/debian-security#g&amp;quot; /etc/apt/sources.list     #163Debian源
apt update &amp;amp;&amp;amp; apt dist-upgrade     #更新软件，可不执行
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;删除订阅弹窗&#34;&gt;删除订阅弹窗&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;sed -Ezi.bak &amp;quot;s/(Ext.Msg.show\(\{\s+title: gettext\(&#39;No valid sub)/void\(\{ \/\/\1/g&amp;quot; /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js &amp;amp;&amp;amp; systemctl restart pveproxy.service
# 执行完成后，浏览器Ctrl+F5强制刷新缓存
&lt;/code&gt;&lt;/pre&gt;
">ProxmoxVE(PVE) 7.0配置国内软件源并删除订阅弹窗</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/YBetv9Lhk/"" data-c="
          &lt;h2 id=&#34;插件安装&#34;&gt;插件安装&lt;/h2&gt;
&lt;p&gt;一直以来使用vim都是简单使用下，有很多不方便的东西，但是可以通过安装插件来让它更加的靠近市面常用的编辑器。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;首先去https://github.com/junegunn/vim-plug&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行对应版本的命令，例如mac(unix)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编辑~/.vimrc&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot; Specify a directory for plugins
&amp;quot; - For Neovim: stdpath(&#39;data&#39;) . &#39;/plugged&#39;
&amp;quot; - Avoid using standard Vim directory names like &#39;plugin&#39;
call plug#begin(&#39;~/.vim/plugged&#39;)
&amp;quot; Initialize plugin system
call plug#end()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编辑完之后在vim中执行:source ~/.vimrc重新加载一下文件&lt;br&gt;
之后就可以发现Plug相关的命令&lt;/p&gt;
&lt;p&gt;贴上我的.vimrc的配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;set nocompatible
&amp;quot; Specify a directory for plugins
&amp;quot; - For Neovim: stdpath(&#39;data&#39;) . &#39;/plugged&#39;
&amp;quot; - Avoid using standard Vim directory names like &#39;plugin&#39;
call plug#begin(&#39;~/.vim/plugged&#39;)
Plug &#39;mhinz/vim-startify&#39;
&amp;quot; Initialize plugin system
call plug#end()
syntax on	&amp;quot; 自动语法高亮
set number &amp;quot; 显示行号
set cindent
set smartindent &amp;quot; 开启新行时使用智能自动缩进
set showmatch &amp;quot; 插入括号时，短暂地跳转到匹配的对应括号
set ruler &amp;quot; 打开状态栏标尺
:set mouse=a &amp;quot;在vim所有模式下开鼠标，复制文档就可以不包含行号了
&lt;/code&gt;&lt;/pre&gt;
">Vim 安装插件管理器 vim-plugin</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/-GPV9MNlH/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;通过源码学习笔记1的实验操作，得到了个基础模版。那么接下来，我们需要实现构建流程，让我们的项目能打包运行。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;构建流程&#34;&gt;构建流程&lt;/h2&gt;
&lt;p&gt;&lt;s&gt;此处我们修改一下tsconfig.json里面的strict为false，暂时不用严格模式&lt;/s&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;我修改一下packages.json的配置文件,新增一个dev的命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json5&#34;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;vue3-plan&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;test&amp;quot;: &amp;quot;echo \&amp;quot;Error: no test specified\&amp;quot; &amp;amp;&amp;amp; exit 1&amp;quot;,
    &amp;quot;dev&amp;quot;: &amp;quot;node scripts/dev.js reactivity -f global&amp;quot;
  },
  &amp;quot;keywords&amp;quot;: [],
  &amp;quot;author&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;ISC&amp;quot;,
  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;esbuild&amp;quot;: &amp;quot;^0.14.38&amp;quot;,
    &amp;quot;minimist&amp;quot;: &amp;quot;^1.2.6&amp;quot;,
    &amp;quot;typescript&amp;quot;: &amp;quot;^4.6.4&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们新建一个文件夹scripts来存放我们打包或者运行时候的启动JS脚本,里面新建一个dev.js,作为启动js脚本。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/*
 * @Author: David
 * @Date: 2022-05-10 11:13:14
 * @LastEditTime: 2022-05-10 13:28:03
 * @LastEditors: David
 * @Description: 打包运行的脚本
 * @FilePath: /vue3-plan/scripts/dev.js
 * 可以输入预定的版权声明、个性签名、空行等
 */
// 这里用到了之前安装的minimist以及esbuild模块
const args = require(&amp;quot;minimist&amp;quot;)(process.argv.slice(2)) // node scripts/dev.js reactivity -f global
const { build } = require(&amp;quot;esbuild&amp;quot;);
// console.log(args)
const { resolve } = require(&#39;path&#39;);// node 内置模块

const target = args._[0] || &amp;quot;reactivity&amp;quot;;
const format = args.f || &#39;global&#39;;// 打包的格式

const pkg = require(resolve(__dirname, `../packages/${target}/package.json`));

// iife 立即执行函数 (function(){})();
// cjs node中的模块 module.exports
// esm 浏览器中的esModule模块 import
const outputFormat = format.startsWith(&amp;quot;global&amp;quot;) ? &#39;iife&#39; : format == &amp;quot;cjs&amp;quot; ? &amp;quot;cjs&amp;quot; : &amp;quot;esm&amp;quot;;

//打包之后文件存放地方
const outFile = resolve(__dirname, `../packages/${target}/dist/${target}.${format}.js`)


//esbuild
//天生就支持ts 
build({
  entryPoints: [resolve(__dirname, `../packages/${target}/src/index.ts`)],
  outfile: outFile, //输出的文件
  bundle: true, //把所有包全部打包到一起
  sourcemap: true,
  format: outputFormat, //输出格式
  globalName: pkg.buildOptions?.name, //打包全局名，上次在package.json中自定义的名字
  platform: format === &amp;quot;cjs&amp;quot; ? &amp;quot;node&amp;quot; : &amp;quot;browser&amp;quot;,//项目运行的平台
  watch: { //监听文件变化
    onRebuild (error) {
      if (!error) {
        console.log(&amp;quot;rebuild~~~&amp;quot;)
      }
    }
  }
}).then(() =&amp;gt; {
  console.log(`watch~~~~`)
})

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过上面2个步骤的操作，我们完成了项目的构建过程，在终端运行如下命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;## 就会执行定义在package.json的dev命令，然后执行scripts/dev.js中的脚本
npm run dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;观察文件夹&#34;&gt;观察文件夹&lt;/h2&gt;
&lt;p&gt;运行上面的命令后会发现reactivity文件夹下多了个dist/reactivity.global.js和reactivity.global.js.map,这个就是打包之后的文件，新建一个html文件，引入reactivity.global.js，放到浏览器上就能看到你的语句了&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Stonewalling/vue3-plan&#34;&gt;源代码地址&lt;/a&gt;&lt;/p&gt;
">vue3源码学习-2-实现构建流程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/7LRUK2OlY/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;本次主要学习目标是构建一个vue3源码的工程项目。需要用到&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;monorepo来作为项目管理的主体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pnpm作为包管理(pnpm作为新型的包管理器，最大优势，快，小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语法选择typescript，目前较为流行的编程语言，JS的扩展版&lt;/p&gt;
&lt;p&gt;项目的文件构成截图&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://micromatrix.cf/post-images/1652254973317.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;开始项目搭建&#34;&gt;开始项目搭建&lt;/h2&gt;
&lt;h3 id=&#34;新建一个文件夹名字就称为vue3-plan吧然后确认是否安装了pnpm&#34;&gt;新建一个文件夹名字就称为vue3-plan吧,然后确认是否安装了pnpm&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;## 查看版本号
pnpm version
## 如果打印出版本信息就表明安装了pnpm

## 如果提示找不到命令的语句，那么只需要安装pnpm就行
## 如果安装失败，可能是node版本过低，我是mac安装了nvm，很轻松切换了v16.15.0
npm install pnpm -g

## 如果你的npm安装速度很慢，不妨试试修改源
npm config set registry https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;进入vue3-plan初始化项目&#34;&gt;进入vue3-plan,初始化项目&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;## 项目信息初始化
pnpm init -y
## 命令执行完之后会生成一个package.json的文件

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;文件主体构成&#34;&gt;文件主体构成&lt;/h3&gt;
&lt;p&gt;本项目目前作为基础的项目学习，在vue3-plan文件夹下新建一个文件夹packages，以及一个pnpm-workspace.yaml的配置文件，该文件时来引导monorepe管理项目的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;#用来搭建monorepo管理项目
packages:
  - &#39;packages/*&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装依赖&#34;&gt;安装依赖&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;## 这里先安装vue，后面我们自己写的vue源码会删除它
pnpm install vue
## 如果用上面的语句安装会提示 你需要指定安装的根目录，因为这个依赖我们会全局使用
## 错误提示
## Running this command will add the dependency to the workspace root, 
## which might not be what you want - if you really meant it, make it explicit by running this command again with the -w flag (or --workspace-root). If you don&#39;t want to see this warning anymore, you may set the ignore-workspace-root-check setting to true.
## 这种警告提示我们使用 -w 来安装到工作根区间
pnpm install vue -w

## 那么我们接下来需要安装typescript，这样才能使用TS语法
## 还需要安装 minimist minimist是一个用于处理命令行调用node指令时，处理node之后的一系列参数的模块。
## 以及esbuild Esbuild, 一个用GO 语言写的Javascript 和Typescript 打包工具，比Webpack 快接近100 倍
## 上面三个都是开发中需要的东西而且模块公用
pnpm install typescript minimist esbuild -w -D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面4个模块安装完之后，这里注意一个问题:&lt;mark&gt;幽灵依赖&lt;/mark&gt; ,这个是指例如vue模块中有个abc依赖，这样我们在安装vue之后就可以直接使用abc模块的东西，但是在未来的时候vue不再使用abc模块，那么就会出现幽灵依赖的问题。为了不出现这种问题我们在vue3-plan的文件夹下建立一个==&lt;code&gt;.npmrc&lt;/code&gt;== 文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;## npm 配置文件
## 解决一个问题 例如vue中有个依赖abc ，那么我们安装了vue就可以直接用abd，有一天vue不依赖abc了，那么你用abc就出错了，未来让这种幽灵依赖以后不出错，就在这里配置羞耻提升
# shamefully-hoist = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除node_modules重新install之后你会发现之前node_module存在.pnpm中的模块会出现在node_module的根目录下，不推荐这么做，万不得已可以这么做。&lt;/p&gt;
&lt;h3 id=&#34;功能代码规划&#34;&gt;功能代码规划&lt;/h3&gt;
&lt;p&gt;主要功能代码实现都在packages文件夹下，例如要实现reactivity和shared功能，我们直接新建2个改名称的文件夹。为了统一的写法。我们采用命令来初始化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;## 进入到packages/reactivity/
pnpm init
## 然后修改一下packages.json
{
  &amp;quot;name&amp;quot;: &amp;quot;@vue/reactivity&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,
  
  ## 这里是自己定义加上的参数,参数名随意
  &amp;quot;buildOptions&amp;quot;:{
    &amp;quot;name&amp;quot;:&amp;quot;VueReactivity&amp;quot;,
    &amp;quot;formats&amp;quot;:[
      &amp;quot;global&amp;quot;, ##全局引用
      &amp;quot;cjs&amp;quot;,
      &amp;quot;esm-budler&amp;quot;
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样的对shared也做一样的事情，然后我们在2个文件夹下都新建src文件夹并在src里面新建一个index.ts文件，在shared/src/index.ts文件中写入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;export const isObject = (value: any) =&amp;gt; {
  return value !== null &amp;amp;&amp;amp; typeof value === &#39;object&#39;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;并在reactivity/src/index.ts中写入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import { isObject } from &#39;@vue/shared&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里先删除vue模块，因为这里正常会提示一个错误，无法找到@vue/shared,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;## 删除vue模块
pnpm uninstall vue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么错误提示找不到模块，那么我们怎么让shared和reavtivity之间关联呢。在vue3-plan下建立一个tsconfig.json文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;// 也可以通过命令来生成一个json文件
// pnpm tsc --init

//写入下面的配置，解析@vue这个目录
{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;outDir&amp;quot;: &amp;quot;dist&amp;quot;, //输出目录
    &amp;quot;sourceMap&amp;quot;: true, //采用sourceMap
    &amp;quot;target&amp;quot;: &amp;quot;es2016&amp;quot;, //目标语法
    &amp;quot;module&amp;quot;: &amp;quot;esnext&amp;quot;, //模块格式
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;, //模块解析方式
    &amp;quot;strict&amp;quot;: true, //严格模式
    &amp;quot;resolveJsonModule&amp;quot;: true, //解析JSON模块
    &amp;quot;esModuleInterop&amp;quot;: true, //允许es6语法引入commonjs模块
    &amp;quot;jsx&amp;quot;: &amp;quot;preserve&amp;quot;, //js不转译
    &amp;quot;lib&amp;quot;: [&amp;quot;esnext&amp;quot;, &amp;quot;dom&amp;quot;], //支持的类库esnext及dom
    &amp;quot;baseUrl&amp;quot;: &amp;quot;.&amp;quot;,
    &amp;quot;paths&amp;quot;: {
      &amp;quot;@vue/*&amp;quot;: [&amp;quot;packages/*/src&amp;quot;]
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;结束&#34;&gt;结束&lt;/h2&gt;
&lt;p&gt;通过上面的操作，构建了一个基础的vue源码学习项目&lt;br&gt;
&lt;a href=&#34;https://github.com/Stonewalling/vue3-plan&#34;&gt;源代码地址&lt;/a&gt;&lt;/p&gt;
">vue3源码学习-1-生成配置信息</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/C5Js8wVhi/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近遇到个需求，需要一个类似于钉钉头部的菜单栏，因为钉钉的头部可以通过函数来渲染需要组件的样式，以及回调函数。所以，第一眼想到了，用单粒模式来模仿这个。那么我们就需要一个全局组件&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;组件编写过程&#34;&gt;组件编写过程&lt;/h2&gt;
&lt;p&gt;首先我们编写一个基础的vue组件，来作为基础的布局。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;header-container-wrapper&amp;quot;&amp;gt;
    &amp;lt;plugin :render=&amp;quot;renderLeftFunc&amp;quot; v-show=&amp;quot;this.renderLeft&amp;quot;&amp;gt;&amp;lt;/plugin&amp;gt;

    &amp;lt;div class=&amp;quot;path-nav-name&amp;quot;&amp;gt;
      {{ navPath }}
    &amp;lt;/div&amp;gt;
    &amp;lt;plugin :render=&amp;quot;renderRightFunc&amp;quot; v-show=&amp;quot;this.renderRight&amp;quot;&amp;gt;&amp;lt;/plugin&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
import plugin from &amp;quot;./render.js&amp;quot;;
export default {
  components: {
    plugin
  },
  computed: {
    renderLeftFunc() {
      return this.renderLeft || function() {};
    },
    renderRightFunc() {
      return this.renderRight || function() {};
    }
  },
  data() {
    //header.js中data的数据定义一样，这里只是方便观察修改组件
    return {
      navPath: &amp;quot;&amp;quot;,
      showLeftContent: false,
      showRightContent: false,
      renderLeft: null,
      renderRight: null,
      pluginName: &amp;quot;&amp;quot;
    };
  }
};
&amp;lt;/script&amp;gt;

&amp;lt;style scoped lang=&amp;quot;scss&amp;quot;&amp;gt;
.header-container-wrapper {
  display: flex;
  align-items: center;
  justify-content: space-around;
  height: 60px;
  .left-container,
  .right-container {
    padding: 16px 24px;
    height: 100%;
  }
  .path-nav-name {
    font-weight: 700;
    font-size: 22px;
    color: #333333;
    margin-left: auto;
    flex: 1 1 auto;
    text-align: center;
  }
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了能在函数中使用render语法渲染组件，这里封装一个render.js来渲染组件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export default {
  //vue2的render示例
  functional: true,
  name: &amp;quot;plugin&amp;quot;,
  props: {
    render: Function,
  },
  render: (h, ctx) =&amp;gt; {
    return ctx.props.render(h)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候我们通过vue.extend这个操作语句来生产一个组件对象。并且我们可以在这个对象上操作前面的基础组件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import Vue from &#39;vue&#39;;
import Header from &amp;quot;./index.vue&amp;quot;;


const Component = Vue.extend(Header);
let instance = null;
function HeaderBox (tarEl, options) {
  if (!instance) {

    instance = new Component({
      el: document.createElement(&#39;div&#39;),
      data () {
        return options;
      }
    });
    //将头部元素插入到第一位
    //返回生成的元素，然后把它挂载到需要挂载到dom元素上
    tarEl.insertBefore(instance.$el, tarEl.firstChild)
  } else {
    // 存在实例，则合并options，更新视图
    Object.assign(instance, options);
  }
}
//添加返回按钮
HeaderBox.addLeftBtn = (renderObj, callback) =&amp;gt; {
  if (instance) {
    instance.showLeftContent = true;
    instance.renderLeft = () =&amp;gt; {
      let h = instance.$createElement;
      return h(
        &amp;quot;div&amp;quot;,
        {
          class: &amp;quot;left-container&amp;quot;,
          on: {
            click: callback
          }
        },
        [
          h(&amp;quot;Icon&amp;quot;, {
            props: {
              type: &amp;quot;ios-arrow-back&amp;quot;
            },
            style: &amp;quot;font-size:24px;&amp;quot;
          }),
          h(
            &amp;quot;span&amp;quot;,
            {
              style: &amp;quot;font-size:18px;&amp;quot;
            },
            &amp;quot;返回&amp;quot;
          )
        ]
      );
    };
  }
}
//移除返回按钮
HeaderBox.removeLeftBtn = () =&amp;gt; {
  if (instance) {
    instance.renderLeft = null;
  }
}

HeaderBox.addTopTitle = (title) =&amp;gt; {
  if (instance) {
    instance.navPath = title;
  }
}
HeaderBox.removeTopTitle = () =&amp;gt; {
  if (instance) {
    instance.navPath = &amp;quot;&amp;quot;
  }
}

export default HeaderBox;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的代码示例中，我们通过instance对象可以操控到基础组件里面的data定义的参数。通过操作data里面的参数，传递render语法来控制渲染组件。其中h由于没有自动注入，所以直接使用时undefined，为了让他能正常工作，参考官网给的代码: const h = this.createElement;我们通过instance对象上的$createElement来赋值h。&lt;/p&gt;
&lt;p&gt;最后我们通过在main.js中全局注册&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import HeaderBox from &amp;quot;@/components/header/header.js&amp;quot;;
Vue.prototype.$HeaderBox = HeaderBox;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样的话任何页面都能通过this.$HeaderBox.addTopTitle(&amp;quot;测试表头&amp;quot;);这样来生成自己的样式，也可以通过扩展header.js里面的HeaderBox对象的属性来扩充基础的组件。&lt;/p&gt;
&lt;p&gt;使用案例如下代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//vue2 中的操作
mounted(){
// 第一次使用初始化，就是你要挂载到哪里到节点下
    this.$HeaderBox(this.$refs.rightHeader);
    this.$nextTick(() =&amp;gt; {
      this.$HeaderBox.addLeftBtn({}, () =&amp;gt; {
        this.$router.go(-1);
      });
    });
}
&lt;/code&gt;&lt;/pre&gt;
">记录一次vue2函数式组件开发+单粒模式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/HQp-4ueUO/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;一直在写vue项目中使用iview的table,它有个设置宽高固定的属性。于是我想在外层套一个div并且这个div动态的随着窗口大小调整，并且满足一定的宽高比，有这种需求是因为一个统计页面上有多个统计类型，其中就有表格。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;padding-bottom实现普通元素固定宽高比,里main的元素获取父元素的全部宽高采用绝对布局position:absolute;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;wrapper&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;intrinsic-aspect-ratio-container&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.wrapper {
   width: 40vw;
 }
 .intrinsic-aspect-ratio-container {
   width: 100%;
   height: 0;
   padding: 0;
   padding-bottom: 75%;
   margin: 50px;
   background-color: lightsalmon;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;aspect-ratio属性指定元素宽高比&lt;/p&gt;
&lt;p&gt;aspect-ratio的语法格式如下：aspect-ratio: &lt;width-ratio&gt;/&lt;height-ratio&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;/* 高度随动 */
.box1 {
  width: 100%;
  height: auto;
  aspect-ratio: 16/9;
}
/* 宽度随动 */
.box1 {
  width: auto;
  height: 100%;
  aspect-ratio: 16/9;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
">CSS3 动态设定div的宽高比</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/1D2XLrY_J/"" data-c="
          &lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;p&gt;通常我们编写脚本中会遇到用户输入字符的操作，对于大部分网站来说，用的都是input或者一些用contenteditable=true这种属性。来完成用户的输入。&lt;/p&gt;
&lt;p&gt;但是，网站通常都在用户输入的时候做一些JS的操作，那么，在JS脚本中如果单纯的在input里面填入文字，他不会触发网站的JS操作。为此查询了下资料，得知可以通过EventTarget.dispatchEvent来重新初始化事件。这样在脚本填入文字的时候就能触发网站原本的操作了。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;代码解决&#34;&gt;代码解决&lt;/h2&gt;
&lt;p&gt;此处是whatApp聊天输入框的捕获&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//获取输入框DOM元素
let list = document.querySelectorAll(&amp;quot;div.selectable-text&amp;quot;); list[list.length - 1]; 
//new 一个动作事件设置冒泡事件来触发他的动作
let event = new Event(&#39;input&#39;,{bubbles:true});
list[list.length - 1].append(&amp;quot;1234&amp;quot;); 
list[list.length - 1].dispatchEvent(event); 
//点击触发，来让他冒泡一下
list[list.length - 1].click()
&lt;/code&gt;&lt;/pre&gt;
">Javascript 模拟输入并触发事件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/gEUTYK8SC/"" data-c="
          &lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;
&lt;p&gt;因PVE7.0更换了Debian11作为内核，软件源管理方式也发生了变更，故原软件源配置方法已失效。&lt;/p&gt;
&lt;p&gt;默认是企业订阅版，如果不做修改，在使用 pveceph init 进行 ceph 初始化安装的时候会将整个环境破坏，切记！&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;strong&gt;登陆各节点Shell控制台&lt;/strong&gt;&lt;br&gt;
**【重要】**将/etc/apt/sources.list.d/pve-enterprise.list 文件内的唯一一条记录注释掉：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;echo&amp;quot;#deb https://enterprise.proxmox.com/debian/pve bullseye pve-enterprise&amp;quot; &amp;gt; /etc/apt/sources.list.d/pve-enterprise.list
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;proxmox软件源更换&#34;&gt;Proxmox软件源更换&lt;/h2&gt;
&lt;p&gt;中科大源（二选一）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;wget https://mirrors.ustc.edu.cn/proxmox/debian/proxmox-release-bullseye.gpg -O /etc/apt/trusted.gpg.d/proxmox-release-bullseye.gpg
echo &amp;quot;deb https://mirrors.ustc.edu.cn/proxmox/debian/pve bullseye pve-no-subscription&amp;quot; &amp;gt; /etc/apt/sources.list.d/pve-no-subscription.list     #中科大源
echo &amp;quot;deb https://mirrors.ustc.edu.cn/proxmox/debian/ceph-pacific bullseye main&amp;quot; &amp;gt; /etc/apt/sources.list.d/ceph.list     #中科大源
sed -i.bak &amp;quot;s#http://download.proxmox.com/debian#https://mirrors.ustc.edu.cn/proxmox/debian#g&amp;quot; /usr/share/perl5/PVE/CLI/pveceph.pm     #中科大源
apt update &amp;amp;&amp;amp; apt dist-upgrade     #更新软件，可不执行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Proxmox中文社区源（二选一）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;wget http://download.proxmox.wiki/debian/proxmox-release-bullseye.gpg -O /etc/apt/trusted.gpg.d/proxmox-release-bullseye.gpg
echo &amp;quot;deb http://download.proxmox.wiki/debian/pve bullseye pve-no-subscription&amp;quot; &amp;gt; /etc/apt/sources.list.d/pve-no-subscription.list     #Proxmox中文社区源
echo &amp;quot;deb https://download.proxmox.wiki/debian/ceph-pacific bullseye main&amp;quot; &amp;gt; /etc/apt/sources.list.d/ceph.list     #Proxmox中文社区源
sed -i.bak &amp;quot;s#http://download.proxmox.com/debian#https://download.proxmox.wiki/debian#g&amp;quot; /usr/share/perl5/PVE/CLI/pveceph.pm     #Proxmox中文社区源
apt update &amp;amp;&amp;amp; apt dist-upgrade     #更新软件，可不执行
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;debian系统源更换&#34;&gt;Debian系统源更换&lt;/h2&gt;
&lt;p&gt;阿里Debian源（二选一）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;sed -i.bak &amp;quot;s#ftp.debian.org/debian#mirrors.aliyun.com/debian#g&amp;quot; /etc/apt/sources.list     #阿里Debian源
sed -i &amp;quot;s#security.debian.org#mirrors.aliyun.com/debian-security#g&amp;quot; /etc/apt/sources.list     #阿里Debian源
apt update &amp;amp;&amp;amp; apt dist-upgrade     #更新软件，可不执行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;163-Debian源（二选一）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;sed -i.bak &amp;quot;s#ftp.debian.org/debian#mirrors.163.com/debian#g&amp;quot; /etc/apt/sources.list     #163Debian源
sed -i &amp;quot;s#security.debian.org#mirrors.163.com/debian-security#g&amp;quot; /etc/apt/sources.list     #163Debian源
apt update &amp;amp;&amp;amp; apt dist-upgrade     #更新软件，可不执行
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;删除订阅弹窗&#34;&gt;删除订阅弹窗&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;sed -Ezi.bak &amp;quot;s/(Ext.Msg.show\(\{\s+title: gettext\(&#39;No valid sub)/void\(\{ \/\/\1/g&amp;quot; /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js &amp;amp;&amp;amp; systemctl restart pveproxy.service
# 执行完成后，浏览器Ctrl+F5强制刷新缓存
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;网络配置&#34;&gt;网络配置&lt;/h2&gt;
&lt;p&gt;提供2套方案:&lt;/p&gt;
&lt;p&gt;一套路由方案&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;attachment:c8772a90263b8cf40dedc8de083aa73d&#34; alt=&#34;截图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;auto lo
iface lo inet loopback

#iface enp2s0f2 inet manual

auto enp2s0f2
iface enp2s0f2 inet static
        address  192.168.1.2
        netmask  255.255.255.0
        gateway  192.168.1.1
        post-up echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
        post-up echo 1 &amp;gt; /proc/sys/net/ipv4/conf/enp2s0f2/proxy_arp

auto vmbr0
iface vmbr0 inet static
        address 100.168.1.2
        netmask 255.255.255.248
        bridge-ports none 
        bridge-stp off
        bridge-fd 0

iface wlp3s0 inet manual

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二套方案同时配置NAT共享IP和独立IP虚拟机&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;auto lo
iface lo inet loopback

llow-hotplug enp2s0f2 #物理网卡名称
iface enp2s0f2 inet manual
 
auto vmbr0
iface vmbr0 inet static
          address 192.168.1.2 #pve宿主机器的IP
          netmask 255.255.255.248
          gateway 192.168.1.1
          bridge-ports enp2s0f2
          bridge-stp off
          bridge-fd 0
 
auto vmbr1
iface vmbr1 inet static
          address 192.168.10.1 #虚拟Ip
          netmask 255.255.255.0
          bridge_ports none
          bridge_stp off
          bridge_fd 0
          post-up echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward
          post-up bash /root/iptables.config.sh
          post-up iptables -t nat -A POSTROUTING -s &#39;192.168.10.0/24&#39; -o vmbr0 -j MASQUERADE
          post-down iptables -t nat -D POSTROUTING -s &#39;192.168.10.0/24&#39; -o vmbr0 -j MASQUERADE

&lt;/code&gt;&lt;/pre&gt;
">ProxmoxVE(PVE) 7.0配置国内软件源并删除订阅弹窗</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/OW7yX44yx/"" data-c="
          &lt;h2 id=&#34;说明&#34;&gt;说明&lt;/h2&gt;
&lt;p&gt;家里笔记本闲着也是闲着，全部装上了CentOS7作为服务器，但是笔记本合上盖子默认是休眠的，所以查资料设置，在此记录一下设置方法：&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;修改方法&#34;&gt;修改方法&lt;/h2&gt;
&lt;p&gt;我们找到CentOS7下对应配置文件，目录为：/etc/systemd/logind.conf，使用vim命令打开&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;vim  /etc/systemd/logind.conf
# HandlePowerKey 按下电源键后的行为，默认power off
# HandleSleepKey 按下挂起键后的行为，默认suspend
# HandleHibernateKey 按下休眠键后的行为，默认hibernate
# HandleLidSwitch 合上笔记本盖后的行为，默认suspend
# 我们把HandleLidSwitch后面的suspend修改为lock，即：
HandleLidSwitch=lock
# ignore 忽略，跳过
# power off 关机
# reboot 重启
# halt 挂起
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;应用生效&#34;&gt;应用生效&lt;/h2&gt;
&lt;p&gt;必须要使用如下命令才能使上面的配置生效&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;systemctl restart systemd-logind
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;systemctl restart systemd-logind&lt;/p&gt;
&lt;h2 id=&#34;说明-2&#34;&gt;说明&lt;/h2&gt;
&lt;p&gt;suspend shell内建指令，可暂停目前正在执行的shell。若要恢复，则必须使用SIGCONT信息。所有的进程都会暂停，但不是消失（halt是进程关闭）hibernate 让笔记本进入休眠状态hybrid-sleep 混合睡眠，主要是为台式机设计的，是睡眠和休眠的结合体，当你选择Hybird时，系统会像休眠一样把内存里的数据从头到尾复制到硬盘里 ，然后进入睡眠状态，即内存和CPU还是活动的，其他设置不活动，这样你想用电脑时就可以快速恢复到之前的状态了，笔记本一般不用这个功能。lock 仅锁屏，计算机继续工作。&lt;/p&gt;
">Linux 笔记本合上盖子依旧运行</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/nDRU5T62b/"" data-c="
          &lt;h2 id=&#34;svg基础属性介绍&#34;&gt;svg基础属性介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;width，height，分别表示svg元素的宽高&lt;/li&gt;
&lt;li&gt;viewBox：
&lt;ol&gt;
&lt;li&gt;前两个参数是对svg元素做位移使用，通常设置为0；&lt;/li&gt;
&lt;li&gt;后两个参数表示svg元素可容纳的大小，具体可参考svg 属性之 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/SVG/Attribute/viewBox&#34;&gt;viewBox&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;circle&#34;&gt;circle&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;cx、cy：圆心的位置&lt;/li&gt;
&lt;li&gt;r：表示半径&lt;/li&gt;
&lt;li&gt;fill: circle 圆的填充色&lt;/li&gt;
&lt;li&gt;stroke-width：边框宽度&lt;/li&gt;
&lt;li&gt;stroke：边框的填充色&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;模拟一个百分比&#34;&gt;模拟一个百分比&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;stroke-dasharray：顾名思义，dash表示虚线，stroke-dash可理解为将边框设置为虚线，stroke-dasharray表示这个属性可以接收多个值，实际上一般是接收两个值，例如：
&lt;ol&gt;
&lt;li&gt;stroke-dasharray: 2,2，表示边框的长度是200，间隔200的宽度，再有200的虚线长度...，依次类推，呈现的效果是 -- -- -- --&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;stroke-dashoffset：设置边框的偏移距离，这个属性是核心，通过设置它的偏移位置来模拟出百分比&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;  &amp;lt;svg width=&amp;quot;18px&amp;quot; height=&amp;quot;18px&amp;quot; viewBox=&amp;quot;0 0 18 18&amp;quot;&amp;gt;
    &amp;lt;circle
      r=&amp;quot;7&amp;quot;
      cx=&amp;quot;9&amp;quot;
      cy=&amp;quot;9&amp;quot;
      fill=&amp;quot;#fff&amp;quot;
      stroke=&amp;quot;#FFC858&amp;quot;
      stroke-width=&amp;quot;14&amp;quot;
      stroke-dasharray=&amp;quot;0 44&amp;quot;
      :id=&amp;quot;`precentCircle${id}`&amp;quot;
    /&amp;gt;
  &amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-scss&#34;&gt;    @keyframes fillup {
       to {
         stroke-dasharray: 44 44;
       }
     }
    svg {
      transform: rotate(-90deg);
      background: #ffc858;
      border-radius: 50%;
    }
    circle {
      animation: fillup 5s linear infinite;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过改变stroke-dasharray的值来完成饼状效果，其中第一个44的值是&lt;br&gt;
要画圆的周长，第二个是圆的周长，因为半径一样所以通过覆盖来完成&lt;br&gt;
饼状图&lt;/p&gt;
">SVG画圆</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/sRjqiELyU/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!--&amp;gt;以下对于vue项目&amp;lt;--&amp;gt;
&amp;lt;div class=&amp;quot;test-div&amp;quot; :vote-badge=&amp;quot;`${blog.voteCount}`&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;test-div1&amp;quot; :style=&amp;quot;{&#39;--item-count&#39;:item.count}&amp;quot; :vote-badge=&amp;quot;`${blog.voteCount}`&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.test-div:after{
  content:attr(vote-badge);
}
.test-div1{
  height:calc(var(--item-count) * 40px);
}
&lt;/code&gt;&lt;/pre&gt;
">Dom节点定义数据</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/TqKZscN02/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;希望只通过css的方法来完成点击改变颜色的需求，这样就不用写冗余的JS代码&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;第一种-input&#34;&gt;第一种 input&lt;/h2&gt;
&lt;p&gt;通过如下的dom结构&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;father&amp;quot;&amp;gt;
  &amp;lt;input class=&amp;quot;children&amp;quot; /&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-scss&#34;&gt;.fahther:focus-within{
  background-color:red;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是上面的方案是 &lt;code&gt;&amp;lt;button&amp;gt;，&amp;lt;input&amp;gt;，&amp;lt;select&amp;gt;，&amp;lt;a&amp;gt;&lt;/code&gt;这类可交互元素，是默认存在focus事件的，而类似&lt;code&gt;&amp;lt;div&amp;gt;，&amp;lt;span&amp;gt; &lt;/code&gt;和&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;这类非交互元素，默认是不能被聚焦的.所以有了第二种方法&lt;/p&gt;
&lt;h2 id=&#34;第二种-div&#34;&gt;第二种 div&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;g-father&amp;quot;&amp;gt;
    &amp;lt;!-- 拥有 focus 事件的 .g-children 元素 --&amp;gt;
    &amp;lt;div class=&amp;quot;g-children&amp;quot; tabindex=&amp;quot;-1&amp;quot;&amp;gt;Click&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里为什么是 tabindex=&amp;quot;-1&amp;quot; 呢，tabindex 负值表示元素是可聚焦的，但是不能通过键盘导航来访问到该元素。因为我们只需要让元素能够获得 focus 事件，而不需要他真的能够被键盘导航来访问。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-scss&#34;&gt;.g-father:focus-within {
    background: #fc0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;问题:需要在点击同样具有focus属性的元素才取消选中的颜色&lt;/p&gt;
&lt;p&gt;发现在FocusEvent对象中relatedTarget，为null的时候发生在点击空白处&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
   /**
     * @description: 点击其他的地方不失焦
     * @param {*} e
     * @return {*}
     * @Date: 2021-12-01 10:14:57
     * @Author: David
     */
    divBlur(e) {
      if (!e.relatedTarget) {
        e.target.focus()
      }
      // console.log(e)
    }
&lt;/code&gt;&lt;/pre&gt;
">如何不通过JS代码实现点击改变颜色</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/yNHfQ6Htp/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;家里积灰的旧电脑，开发性能不够，但是用来做个网络小主机妥妥的够用，安装来pve7.0版本后面升级来小版本11，加入重要的功能可以安装win11了，索性升级下，然后升级不了，出现BUG。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ol&gt;
&lt;li&gt;修改了源，但是无法升级，提示解析错误&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vim /etc/resolve.conf
##添加ipv4的解析到文件中
##国内
nameserver 101.226.4.6
##国外
nameserver 8.8.4.4
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;升级中提示The following signatures couldn&#39;t be verified because the public key is not available&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#将升级中出现的
#The following signatures couldn&#39;t be verified because the public key is not available: NO_PUBKEY xxxxxxxx（&#39;公钥编码&#39;）
#复制出上面的密钥，在终端中输入下面的语句
apt-key adv --keyserver keyserver.ubuntu.com --recv-keys &#39;公钥编码&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
">proxmox7 升级遇到的错误</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/yZaRIC-_i/"" data-c="
          &lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;Mac上的漂亮终端oh-my-zsh + iterm2 + homebrew 包管理器QQ&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;安装oh-my-zshiterm2&#34;&gt;安装oh-my-zsh+iterm2&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://micromatrix.cf/post-images/1652236755163.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
去&lt;a href=&#34;https://iterm2.com/&#34;&gt;iterm2官网&lt;/a&gt;下载安装软件，之后安装zsh&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 安装 zsh
brew install zsh
# 设置zsh为你的默认shell
chsh -s /usr/local/bin/zsh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在GitHub的osx-terminal-theme项目主页里寻找你喜欢的主题&lt;br&gt;
在schemes目录里找到对应的主题文件并双击安装到Terminal, 设置为默认&lt;/p&gt;
&lt;p&gt;如果您觉得我的主题颜色不错，可以试试&lt;a href=&#34;https://gist.github.com/tonyxu-io/6b845cb1a53622eb4f1ce4063365e427&#34;&gt;我的主题配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装之后就可以安装oh-my-zsh(Oh My Zsh 是一个令人愉快的、开源的、社区驱动的管理zsh配置的框架。它为我们带来了数千个有用的功能、助手、插件、主题，和其他一些令你惊叹的功能)&lt;/p&gt;
&lt;p&gt;安装oh-my-zsh:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;sh -c &amp;quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装oh-my-zsh主题&lt;br&gt;
内置主题列表&lt;br&gt;
oh-my-zsh提供一批内置主题，可以直接设置使用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在内置主题列表寻找你你喜欢的主题: https://github.com/robbyrussell/oh-my-zsh/wiki/Themes&lt;/li&gt;
&lt;li&gt;在~/.zshrc配置文件里设置ZSH_THEME为你的主题名称&lt;/li&gt;
&lt;li&gt;激活设置source ~/.zshrc&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;第三方主题列表&#34;&gt;第三方主题列表&lt;/h3&gt;
&lt;p&gt;许多第三方也开发了供oh-my-zsh使用的主题，可以去第三方主题列表查看和安装:&lt;br&gt;
https://github.com/robbyrussell/oh-my-zsh/wiki/External-themes&lt;br&gt;
安装oh-my-zsh必备插件&lt;br&gt;
oh-my-zsh有非常丰富的插件可供使用，下面列举一些必备插件，可以大幅提高生产力。&lt;br&gt;
示例如下:&lt;/p&gt;
&lt;p&gt;~/.zshrc:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;plugins=(
  git
  extract
  autojump
  zsh-autosuggestions
  zsh-syntax-highlighting
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;git自带插件，可以使用缩写命令, 比如 gaa -&amp;gt; git add --all, 通过alias | grep git查看所有支持缩写命令&lt;br&gt;
激活: 添加到~/.zshrc的plugins列表&lt;br&gt;
extract&lt;br&gt;
自带插件，不用再使用复杂的tar来解压压缩包了&lt;br&gt;
激活: 添加 extract 到 ~/.zshrc 的plugins列表&lt;br&gt;
autojump&lt;br&gt;
使用j命令直接快速进入某个目录, 比如 j Downloads -&amp;gt; cd ~/Downloads&lt;br&gt;
安装: brew install autojump&lt;br&gt;
激活: 添加 autojump 至 ~/.zshrc 配置文件的插件列表。&lt;br&gt;
zsh-syntax-highlighting&lt;br&gt;
命令高亮插件，命令不再只是同一个颜色了&lt;br&gt;
安装: brew install zsh-syntax-highlighting&lt;br&gt;
激活: 添加 zsh-syntax-highlighting 至 ~/.zshrc 配置文件的插件列表。&lt;br&gt;
zsh-autosuggestions&lt;br&gt;
输入时按右方向键→自动补全命令&lt;br&gt;
安装: brew install zsh-autosuggestions&lt;br&gt;
激活: 添加 zsh-autosuggestions 至 ~/.zshrc 配置文件的插件列表。&lt;br&gt;
我自己的~/.zshrc oh-my-zsh的配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;# Path to your oh-my-zsh installation.
export ZSH=/Users/tonxu/.oh-my-zsh
# theme
ZSH_THEME=&amp;quot;robbyrussell&amp;quot;
# plugins
plugins=(
  git
  extract
  autojump
  zsh-autosuggestions
  zsh-syntax-highlighting
)
source $ZSH/oh-my-zsh.sh
# set language
export LANG=en_US.UTF-8
# default editor
export EDITOR=&#39;vi&#39;
# ssh key path
export SSH_KEY_PATH=&amp;quot;~/.ssh/rsa_id&amp;quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;cd ~
ls -a
#查看当前目录下有没有.zshrc这个文件，没有的话
touch .zshrc
&lt;/code&gt;&lt;/pre&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;p&gt;以下是我的完整配置其他的例如mysql的路径也添加在此处我暂时不加入其中，终端代理通过privoxy，没安装brew之前可以先用用上方注释的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;#zsh manager
source ~/.zinit/bin/zinit.zsh

#zinit load zsh plugins
#zinit ice depth=1; zinit light zsh-users/zsh-autosuggestions
#zinit ice depth=1; zinit light zsh-users/zsh-syntax-highlighting
# Fast-syntax-highlighting &amp;amp; autosuggestions
zinit wait lucid for \
 atinit&amp;quot;ZINIT[COMPINIT_OPTS]=-C; zpcompinit; zpcdreplay&amp;quot; \
    zdharma/fast-syntax-highlighting \
 atload&amp;quot;!_zsh_autosuggest_start&amp;quot; \
    zsh-users/zsh-autosuggestions \
 blockf \
    zsh-users/zsh-completions


# If you come from bash you might have to change your $PATH.
# export PATH=$HOME/bin:/usr/local/bin:$PATH

# Path to your oh-my-zsh installation.
export ZSH=&amp;quot;/Users/davidmorgan/.oh-my-zsh&amp;quot;

# Set name of the theme to load --- if set to &amp;quot;random&amp;quot;, it will
# load a random theme each time oh-my-zsh is loaded, in which case,
# to know which specific one was loaded, run: echo $RANDOM_THEME
# See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
ZSH_THEME=&amp;quot;dracula&amp;quot;

# Set list of themes to pick from when loading at random
# Setting this variable when ZSH_THEME=random will cause zsh to load
# a theme from this variable instead of looking in ~/.oh-my-zsh/themes/
# If set to an empty array, this variable will have no effect.
# ZSH_THEME_RANDOM_CANDIDATES=( &amp;quot;robbyrussell&amp;quot; &amp;quot;agnoster&amp;quot; )

# Uncomment the following line to use case-sensitive completion.
# CASE_SENSITIVE=&amp;quot;true&amp;quot;

# Uncomment the following line to use hyphen-insensitive completion.
# Case-sensitive completion must be off. _ and - will be interchangeable.
# HYPHEN_INSENSITIVE=&amp;quot;true&amp;quot;

# Uncomment the following line to disable bi-weekly auto-update checks.
# DISABLE_AUTO_UPDATE=&amp;quot;true&amp;quot;

# Uncomment the following line to automatically update without prompting.
# DISABLE_UPDATE_PROMPT=&amp;quot;true&amp;quot;

# Uncomment the following line to change how often to auto-update (in days).
# export UPDATE_ZSH_DAYS=13

# Uncomment the following line if pasting URLs and other text is messed up.
# DISABLE_MAGIC_FUNCTIONS=true

# Uncomment the following line to disable colors in ls.
# DISABLE_LS_COLORS=&amp;quot;true&amp;quot;

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE=&amp;quot;true&amp;quot;

# Uncomment the following line to enable command auto-correction.
# ENABLE_CORRECTION=&amp;quot;true&amp;quot;

# Uncomment the following line to display red dots whilst waiting for completion.
# COMPLETION_WAITING_DOTS=&amp;quot;true&amp;quot;

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY=&amp;quot;true&amp;quot;

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# &amp;quot;mm/dd/yyyy&amp;quot;|&amp;quot;dd.mm.yyyy&amp;quot;|&amp;quot;yyyy-mm-dd&amp;quot;
# or set a custom format using the strftime function format specifications,
# see &#39;man strftime&#39; for details.
# HIST_STAMPS=&amp;quot;mm/dd/yyyy&amp;quot;

# Would you like to use another custom folder than $ZSH/custom?
# ZSH_CUSTOM=/path/to/new-custom-folder

# Which plugins would you like to load?
# Standard plugins can be found in ~/.oh-my-zsh/plugins/*
# Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(git z)

source $ZSH/oh-my-zsh.sh

# User configuration
source ~/.bash_profile

# export MANPATH=&amp;quot;/usr/local/man:$MANPATH&amp;quot;

# You may need to manually set your language environment
# export LANG=en_US.UTF-8

# Preferred editor for local and remote sessions
# if [[ -n $SSH_CONNECTION ]]; then
#   export EDITOR=&#39;vim&#39;
# else
#   export EDITOR=&#39;mvim&#39;
# fi

# Compilation flags
# export ARCHFLAGS=&amp;quot;-arch x86_64&amp;quot;

# Set personal aliases, overriding those provided by oh-my-zsh libs,
# plugins, and themes. Aliases can be placed here, though oh-my-zsh
# users are encouraged to define aliases within the ZSH_CUSTOM folder.
# For a full list of active aliases, run `alias`.
#
# Example aliases
# alias zshconfig=&amp;quot;mate ~/.zshrc&amp;quot;
# alias ohmyzsh=&amp;quot;mate ~/.oh-my-zsh&amp;quot;

export NVM_DIR=&amp;quot;$HOME/.nvm&amp;quot;
[ -s &amp;quot;$NVM_DIR/nvm.sh&amp;quot; ] &amp;amp;&amp;amp; \. &amp;quot;$NVM_DIR/nvm.sh&amp;quot;  # This loads nvm
[ -s &amp;quot;$NVM_DIR/bash_completion&amp;quot; ] &amp;amp;&amp;amp; \. &amp;quot;$NVM_DIR/bash_completion&amp;quot;  # This loads nvm bash_completion

#add mysql
alias mysql=/usr/local/mysql/bin/mysql

# The next line updates PATH for the Google Cloud SDK.
if [ -f &#39;/Users/davidmorgan/google/google-cloud-sdk/path.zsh.inc&#39; ]; then . &#39;/Users/davidmorgan/google/google-cloud-sdk/path.zsh.inc&#39;; fi

# The next line enables shell command completion for gcloud.
if [ -f &#39;/Users/davidmorgan/google/google-cloud-sdk/completion.zsh.inc&#39; ]; then . &#39;/Users/davidmorgan/google/google-cloud-sdk/completion.zsh.inc&#39;; fi

# terminal proxy setting
# export http_proxy=&#39;http://localhost:8889&#39;
# export https_proxy=&#39;http://localhost:8889&#39;

#ADD A SWITCH  FUNCTION
function proxy_off(){
    unset http_proxy
    unset https_proxy
    echo -e &amp;quot;已关闭代理&amp;quot;
}
function proxy_on() {
    export no_proxy=&amp;quot;localhost,127.0.0.1,localaddress,.localdomain.com&amp;quot;
    export http_proxy=&amp;quot;http://127.0.0.1:8118&amp;quot;
    export https_proxy=$http_proxy
    echo -e &amp;quot;已开启代理&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装homebrew&#34;&gt;安装homebrew&lt;/h2&gt;
&lt;p&gt;安装homebrew，之后就可以通过它来安装其他的软件或者插件。访问&lt;a href=&#34;https://brew.sh/&#34;&gt;homebrew网站&lt;/a&gt; 进行安装。安装brew之后就可以通过brew来安装，卸载软件包，但是官方的uninstall不会卸载软件的依赖包，只会卸载本身的包，为了干净的删除软件安装rmtree&lt;/p&gt;
&lt;p&gt;国内的用户安装homebrew会出现各种网络问题，因为防火墙的原因导致github访问经常出现问题，所以这里有一个大佬写的&lt;a href=&#34;https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh&#34;&gt;国内一键安装脚本&lt;/a&gt;&lt;br&gt;
也可以执行下面的命令一键安装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;/bin/zsh -c &amp;quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;brew tap beeftornado/rmtree
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后通过&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;brew rmtree &amp;lt;软件名&amp;gt;
brew cleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;vim安装vim-plugin&#34;&gt;vim安装vim-plugin&lt;/h2&gt;
&lt;p&gt;Vim本身也有很多插件，而插件管理器有很多，比较火的这个vim-plugin是一个异步更新的管理器。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先去https://github.com/junegunn/vim-plug下载&lt;/li&gt;
&lt;li&gt;执行对应版本的命令，例如mac(unix)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;编辑~/.vimrc&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot; Specify a directory for plugins
&amp;quot; - For Neovim: stdpath(&#39;data&#39;) . &#39;/plugged&#39;
&amp;quot; - Avoid using standard Vim directory names like &#39;plugin&#39;
call plug#begin(&#39;~/.vim/plugged&#39;)
&amp;quot; Initialize plugin system
call plug#end()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;编辑完之后在vim中执行:source ~/.vimrc重新加载一下文件&lt;br&gt;
之后就可以发现Plug相关的命令&lt;/p&gt;
&lt;p&gt;贴上我的.vimrc的配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;set nocompatible
&amp;quot; Specify a directory for plugins
&amp;quot; - For Neovim: stdpath(&#39;data&#39;) . &#39;/plugged&#39;
&amp;quot; - Avoid using standard Vim directory names like &#39;plugin&#39;
call plug#begin(&#39;~/.vim/plugged&#39;)
Plug &#39;mhinz/vim-startify&#39;
&amp;quot; Initialize plugin system
call plug#end()
syntax on	&amp;quot; 自动语法高亮
set number &amp;quot; 显示行号
set cindent
set smartindent &amp;quot; 开启新行时使用智能自动缩进
set showmatch &amp;quot; 插入括号时，短暂地跳转到匹配的对应括号
set ruler &amp;quot; 打开状态栏标尺
:set mouse=a &amp;quot;在vim所有模式下开鼠标，复制文档就可以不包含行号了
&lt;/code&gt;&lt;/pre&gt;
">iterm+oh-my-zsh+homebrew</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://micromatrix.cf/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;一个技术菜鸟的博客网站，记录学习笔记和踩到到坑&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;p&gt;DavidMorgan&lt;/p&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;p&gt;战地一,战地五&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;p&gt;ezioauditorebaobao@gmail.com&lt;/p&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }

  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


  <!-- <script
    src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script> -->
    <script
    src="https://unpkg.com/smooth-scroll@16.1.3/dist/smooth-scroll.polyfills.min.js"></script>
  <script>
    var scroll = new SmoothScroll('a[href*="#"]', {
      speed: 200
    });
  </script>




  <script src="/media/js/cool.js"></script>



  <div class="snow-container"></div>
  <script color="0,205,205" pointer-events="auto" zIndex="-1" opacity='0.7' count="99" src="/media/js/bg/canvas-nest.js"></script>

</html>